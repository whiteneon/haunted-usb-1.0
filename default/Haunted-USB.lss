
Haunted-USB.elf:     file format elf32-avr

Sections:
Idx Name          Size      VMA       LMA       File off  Algn
  0 .text         00000bcc  00000000  00000000  00000094  2**1
                  CONTENTS, ALLOC, LOAD, READONLY, CODE
  1 .data         00000008  00800060  00000bcc  00000c60  2**0
                  CONTENTS, ALLOC, LOAD, DATA
  2 .bss          00000040  00800068  00800068  00000c68  2**0
                  ALLOC
  3 .debug_aranges 00000090  00000000  00000000  00000c68  2**3
                  CONTENTS, READONLY, DEBUGGING
  4 .debug_pubnames 00000214  00000000  00000000  00000cf8  2**0
                  CONTENTS, READONLY, DEBUGGING
  5 .debug_info   00000c22  00000000  00000000  00000f0c  2**0
                  CONTENTS, READONLY, DEBUGGING
  6 .debug_abbrev 000004f8  00000000  00000000  00001b2e  2**0
                  CONTENTS, READONLY, DEBUGGING
  7 .debug_line   00000970  00000000  00000000  00002026  2**0
                  CONTENTS, READONLY, DEBUGGING
  8 .debug_frame  000000a0  00000000  00000000  00002998  2**2
                  CONTENTS, READONLY, DEBUGGING
  9 .debug_str    000004a7  00000000  00000000  00002a38  2**0
                  CONTENTS, READONLY, DEBUGGING
 10 .debug_loc    000005e0  00000000  00000000  00002edf  2**0
                  CONTENTS, READONLY, DEBUGGING
 11 .debug_ranges 00000100  00000000  00000000  000034bf  2**0
                  CONTENTS, READONLY, DEBUGGING

Disassembly of section .text:

00000000 <__vectors>:
   0:	59 c0       	rjmp	.+178    	; 0xb4 <__ctors_end>
   2:	73 c0       	rjmp	.+230    	; 0xea <__bad_interrupt>
   4:	9f c0       	rjmp	.+318    	; 0x144 <__vector_2>
   6:	71 c0       	rjmp	.+226    	; 0xea <__bad_interrupt>
   8:	70 c0       	rjmp	.+224    	; 0xea <__bad_interrupt>
   a:	6f c0       	rjmp	.+222    	; 0xea <__bad_interrupt>
   c:	6e c0       	rjmp	.+220    	; 0xea <__bad_interrupt>
   e:	6d c0       	rjmp	.+218    	; 0xea <__bad_interrupt>
  10:	6c c0       	rjmp	.+216    	; 0xea <__bad_interrupt>
  12:	6b c0       	rjmp	.+214    	; 0xea <__bad_interrupt>
  14:	6a c0       	rjmp	.+212    	; 0xea <__bad_interrupt>
  16:	69 c0       	rjmp	.+210    	; 0xea <__bad_interrupt>
  18:	68 c0       	rjmp	.+208    	; 0xea <__bad_interrupt>
  1a:	67 c0       	rjmp	.+206    	; 0xea <__bad_interrupt>
  1c:	66 c0       	rjmp	.+204    	; 0xea <__bad_interrupt>

0000001e <usbDescriptorHidReport>:
  1e:	05 01 09 06 a1 01 05 07 19 e0 29 e7 15 00 25 01     ..........)...%.
  2e:	75 01 95 08 81 02 95 01 75 08 25 65 19 00 29 65     u.......u.%e..)e
  3e:	81 00 c0                                            ...

00000041 <usbDescriptorString0>:
  41:	04 03 09 04                                         ....

00000045 <usbDescriptorStringVendor>:
  45:	24 03 69 00 6d 00 61 00 6b 00 65 00 70 00 72 00     $.i.m.a.k.e.p.r.
  55:	6f 00 6a 00 65 00 63 00 74 00 73 00 2e 00 63 00     o.j.e.c.t.s...c.
  65:	6f 00 6d 00                                         o.m.

00000069 <usbDescriptorStringDevice>:
  69:	16 03 48 00 61 00 75 00 6e 00 74 00 65 00 64 00     ..H.a.u.n.t.e.d.
  79:	55 00 53 00 42 00                                   U.S.B.

0000007f <usbDescriptorDevice>:
  7f:	12 01 10 01 00 00 00 08 42 42 31 e1 00 01 01 02     ........BB1.....
  8f:	00 01                                               ..

00000091 <usbDescriptorConfiguration>:
  91:	09 02 22 00 01 01 00 80 19 09 04 00 00 01 03 00     ..".............
  a1:	00 00 09 21 01 01 00 01 22 23 00 07 05 81 03 08     ...!...."#......
  b1:	00 0a 00                                            ...

000000b4 <__ctors_end>:
  b4:	11 24       	eor	r1, r1
  b6:	1f be       	out	0x3f, r1	; 63
  b8:	cf e5       	ldi	r28, 0x5F	; 95
  ba:	d2 e0       	ldi	r29, 0x02	; 2
  bc:	de bf       	out	0x3e, r29	; 62
  be:	cd bf       	out	0x3d, r28	; 61

000000c0 <__do_copy_data>:
  c0:	10 e0       	ldi	r17, 0x00	; 0
  c2:	a0 e6       	ldi	r26, 0x60	; 96
  c4:	b0 e0       	ldi	r27, 0x00	; 0
  c6:	ec ec       	ldi	r30, 0xCC	; 204
  c8:	fb e0       	ldi	r31, 0x0B	; 11
  ca:	02 c0       	rjmp	.+4      	; 0xd0 <.do_copy_data_start>

000000cc <.do_copy_data_loop>:
  cc:	05 90       	lpm	r0, Z+
  ce:	0d 92       	st	X+, r0

000000d0 <.do_copy_data_start>:
  d0:	a8 36       	cpi	r26, 0x68	; 104
  d2:	b1 07       	cpc	r27, r17
  d4:	d9 f7       	brne	.-10     	; 0xcc <.do_copy_data_loop>

000000d6 <__do_clear_bss>:
  d6:	10 e0       	ldi	r17, 0x00	; 0
  d8:	a8 e6       	ldi	r26, 0x68	; 104
  da:	b0 e0       	ldi	r27, 0x00	; 0
  dc:	01 c0       	rjmp	.+2      	; 0xe0 <.do_clear_bss_start>

000000de <.do_clear_bss_loop>:
  de:	1d 92       	st	X+, r1

000000e0 <.do_clear_bss_start>:
  e0:	a8 3a       	cpi	r26, 0xA8	; 168
  e2:	b1 07       	cpc	r27, r17
  e4:	e1 f7       	brne	.-8      	; 0xde <.do_clear_bss_loop>
  e6:	6c d2       	rcall	.+1240   	; 0x5c0 <main>
  e8:	6f c5       	rjmp	.+2782   	; 0xbc8 <_exit>

000000ea <__bad_interrupt>:
  ea:	8a cf       	rjmp	.-236    	; 0x0 <__vectors>

000000ec <usbCrc16>:
;   r20/21: polynomial
;   r23: scratch
;   r24/25: crc-sum
;   r26/27=X: ptr
usbCrc16:
    mov     ptrL, argPtrL
  ec:	a8 2f       	mov	r26, r24
    mov     ptrH, argPtrH
  ee:	b9 2f       	mov	r27, r25
    ldi     resCrcL, 0
  f0:	80 e0       	ldi	r24, 0x00	; 0
    ldi     resCrcH, 0
  f2:	90 e0       	ldi	r25, 0x00	; 0
    ldi     polyL, lo8(0xa001)
  f4:	41 e0       	ldi	r20, 0x01	; 1
    ldi     polyH, hi8(0xa001)
  f6:	50 ea       	ldi	r21, 0xA0	; 160
    com     argLen      ; argLen = -argLen - 1
  f8:	60 95       	com	r22

000000fa <crcByteLoop>:
crcByteLoop:
    subi    argLen, -1
  fa:	6f 5f       	subi	r22, 0xFF	; 255
    brcc    crcReady    ; modified loop to ensure that carry is set below
  fc:	58 f4       	brcc	.+22     	; 0x114 <crcReady>
    ld      byte, ptr+
  fe:	2d 91       	ld	r18, X+
    ldi     bitCnt, -8  ; strange loop counter to ensure that carry is set where we need it
 100:	38 ef       	ldi	r19, 0xF8	; 248
    eor     resCrcL, byte
 102:	82 27       	eor	r24, r18

00000104 <crcBitLoop>:
crcBitLoop:
    ror     resCrcH     ; carry is always set here
 104:	97 95       	ror	r25
    ror     resCrcL
 106:	87 95       	ror	r24
    brcs    crcNoXor
 108:	10 f0       	brcs	.+4      	; 0x10e <crcNoXor>
    eor     resCrcL, polyL
 10a:	84 27       	eor	r24, r20
    eor     resCrcH, polyH
 10c:	95 27       	eor	r25, r21

0000010e <crcNoXor>:
crcNoXor:
    subi    bitCnt, -1
 10e:	3f 5f       	subi	r19, 0xFF	; 255
    brcs    crcBitLoop
 110:	c8 f3       	brcs	.-14     	; 0x104 <crcBitLoop>
    rjmp    crcByteLoop
 112:	f3 cf       	rjmp	.-26     	; 0xfa <crcByteLoop>

00000114 <crcReady>:
crcReady:
    ret
 114:	08 95       	ret

00000116 <usbCrc16Append>:
; Thanks to Reimar Doeffinger for optimizing this CRC routine!

; extern unsigned usbCrc16Append(unsigned char *data, unsigned char len);
usbCrc16Append:
    rcall   usbCrc16
 116:	ea df       	rcall	.-44     	; 0xec <usbCrc16>
    st      ptr+, resCrcL
 118:	8d 93       	st	X+, r24
    st      ptr+, resCrcH
 11a:	9d 93       	st	X+, r25
    ret
 11c:	08 95       	ret

0000011e <usbMeasureFrameLength>:

; extern unsigned usbMeasurePacketLength(void);
; returns time between two idle strobes in multiples of 7 CPU clocks
.global usbMeasureFrameLength
usbMeasureFrameLength:
    ldi     cntH, 6         ; wait ~ 10 ms for D- == 0
 11e:	a6 e0       	ldi	r26, 0x06	; 6
    clr     cnt16L
 120:	88 27       	eor	r24, r24
    clr     cnt16H
 122:	99 27       	eor	r25, r25

00000124 <usbMFTime16>:
usbMFTime16:
    dec     cntH
 124:	aa 95       	dec	r26
    breq    usbMFTimeout
 126:	69 f0       	breq	.+26     	; 0x142 <usbMFTimeout>

00000128 <usbMFWaitStrobe>:
usbMFWaitStrobe:            ; first wait for D- == 0 (idle strobe)
    sbiw    cnt16, 1        ;[0] [6]
 128:	01 97       	sbiw	r24, 0x01	; 1
    breq    usbMFTime16     ;[2]
 12a:	e1 f3       	breq	.-8      	; 0x124 <usbMFTime16>
    sbic    USBIN, USBMINUS ;[3]
 12c:	b3 99       	sbic	0x16, 3	; 22
    rjmp    usbMFWaitStrobe ;[4]
 12e:	fc cf       	rjmp	.-8      	; 0x128 <usbMFWaitStrobe>

00000130 <usbMFWaitIdle>:
usbMFWaitIdle:              ; then wait until idle again
    sbis    USBIN, USBMINUS ;1 wait for D- == 1
 130:	b3 9b       	sbis	0x16, 3	; 22
    rjmp    usbMFWaitIdle   ;2
 132:	fe cf       	rjmp	.-4      	; 0x130 <usbMFWaitIdle>
    ldi     cnt16L, 1       ;1 represents cycles so far
 134:	81 e0       	ldi	r24, 0x01	; 1
    clr     cnt16H          ;1
 136:	99 27       	eor	r25, r25

00000138 <usbMFWaitLoop>:
usbMFWaitLoop:
    in      cntH, USBIN     ;[0] [7]
 138:	a6 b3       	in	r26, 0x16	; 22
    adiw    cnt16, 1        ;[1]
 13a:	01 96       	adiw	r24, 0x01	; 1
    breq    usbMFTimeout    ;[3]
 13c:	11 f0       	breq	.+4      	; 0x142 <usbMFTimeout>
    andi    cntH, USBMASK   ;[4]
 13e:	a8 71       	andi	r26, 0x18	; 24
    brne    usbMFWaitLoop   ;[5]
 140:	d9 f7       	brne	.-10     	; 0x138 <usbMFWaitLoop>

00000142 <usbMFTimeout>:
usbMFTimeout:
#if resL != cnt16L
    mov     resL, cnt16L
    mov     resH, cnt16H
#endif
    ret
 142:	08 95       	ret

00000144 <__vector_2>:
; when instruction starts


USB_INTR_VECTOR:
;order of registers pushed: YL, SREG [sofError], r0, YH, shift, x1, x2, x3, x4, cnt
    push    YL                  ;[-23] push only what is necessary to sync with edge ASAP
 144:	cf 93       	push	r28
    in      YL, SREG            ;[-21]
 146:	cf b7       	in	r28, 0x3f	; 63
    push    YL                  ;[-20]
 148:	cf 93       	push	r28

0000014a <waitForJ>:
;----------------------------------------------------------------------------
;sync byte (D-) pattern LSb to MSb: 01010100 [1 = idle = J, 0 = K]
;sync up with J to K edge during sync pattern -- use fastest possible loops
;first part has no timeout because it waits for IDLE or SE1 (== disconnected)
waitForJ:
    sbis    USBIN, USBMINUS     ;[-18] wait for D- == 1
 14a:	b3 9b       	sbis	0x16, 3	; 22
    rjmp    waitForJ
 14c:	fe cf       	rjmp	.-4      	; 0x14a <waitForJ>

0000014e <waitForK>:
waitForK:
;The following code results in a sampling window of < 1/4 bit which meets the spec.
    sbis    USBIN, USBMINUS     ;[-15]
 14e:	b3 9b       	sbis	0x16, 3	; 22
    rjmp    foundK              ;[-14]
 150:	0b c0       	rjmp	.+22     	; 0x168 <foundK>
    sbis    USBIN, USBMINUS
 152:	b3 9b       	sbis	0x16, 3	; 22
    rjmp    foundK
 154:	09 c0       	rjmp	.+18     	; 0x168 <foundK>
    sbis    USBIN, USBMINUS
 156:	b3 9b       	sbis	0x16, 3	; 22
    rjmp    foundK
 158:	07 c0       	rjmp	.+14     	; 0x168 <foundK>
    sbis    USBIN, USBMINUS
 15a:	b3 9b       	sbis	0x16, 3	; 22
    rjmp    foundK
 15c:	05 c0       	rjmp	.+10     	; 0x168 <foundK>
    sbis    USBIN, USBMINUS
 15e:	b3 9b       	sbis	0x16, 3	; 22
    rjmp    foundK
 160:	03 c0       	rjmp	.+6      	; 0x168 <foundK>
    sbis    USBIN, USBMINUS
 162:	b3 9b       	sbis	0x16, 3	; 22
    rjmp    foundK
 164:	01 c0       	rjmp	.+2      	; 0x168 <foundK>
#if USB_COUNT_SOF
    lds     YL, usbSofCount
    inc     YL
    sts     usbSofCount, YL
#endif  /* USB_COUNT_SOF */
    rjmp    sofError
 166:	d5 c0       	rjmp	.+426    	; 0x312 <sofError>

00000168 <foundK>:
foundK:                         ;[-12]
;{3, 5} after falling D- edge, average delay: 4 cycles [we want 5 for center sampling]
;we have 1 bit time for setup purposes, then sample again. Numbers in brackets
;are cycles from center of first sync (double K) bit after the instruction
    push    r0                  ;[-12]
 168:	0f 92       	push	r0
;   [---]                       ;[-11]
    push    YH                  ;[-10]
 16a:	df 93       	push	r29
;   [---]                       ;[-9]
    lds     YL, usbInputBufOffset;[-8]
 16c:	c0 91 8b 00 	lds	r28, 0x008B
;   [---]                       ;[-7]
    clr     YH                  ;[-6]
 170:	dd 27       	eor	r29, r29
    subi    YL, lo8(-(usbRxBuf));[-5] [rx loop init]
 172:	ce 56       	subi	r28, 0x6E	; 110
    sbci    YH, hi8(-(usbRxBuf));[-4] [rx loop init]
 174:	df 4f       	sbci	r29, 0xFF	; 255
    mov     r0, x2              ;[-3] [rx loop init]
 176:	01 2e       	mov	r0, r17
    sbis    USBIN, USBMINUS     ;[-2] we want two bits K (sample 2 cycles too early)
 178:	b3 9b       	sbis	0x16, 3	; 22
    rjmp    haveTwoBitsK        ;[-1]
 17a:	03 c0       	rjmp	.+6      	; 0x182 <haveTwoBitsK>
    pop     YH                  ;[0] undo the pushes from before
 17c:	df 91       	pop	r29
    pop     r0                  ;[2]
 17e:	0f 90       	pop	r0
    rjmp    waitForK            ;[4] this was not the end of sync, retry
 180:	e6 cf       	rjmp	.-52     	; 0x14e <waitForK>

00000182 <haveTwoBitsK>:

;----------------------------------------------------------------------------
; push more registers and initialize values while we sample the first bits:
;----------------------------------------------------------------------------
haveTwoBitsK:               ;[1]
    push    shift           ;[1]
 182:	2f 93       	push	r18
    push    x1              ;[3]
 184:	0f 93       	push	r16
    push    x2              ;[5]
 186:	1f 93       	push	r17
    push    x3              ;[7]
 188:	4f 93       	push	r20
    ldi     shift, 0xff     ;[9] [rx loop init]
 18a:	2f ef       	ldi	r18, 0xFF	; 255
    ori     x3, 0xff        ;[10] [rx loop init] == ser x3, clear zero flag
 18c:	4f 6f       	ori	r20, 0xFF	; 255

    in      x1, USBIN       ;[11] <-- sample bit 0
 18e:	06 b3       	in	r16, 0x16	; 22
    bst     x1, USBMINUS    ;[12]
 190:	03 fb       	bst	r16, 3
    bld     shift, 0        ;[13]
 192:	20 f9       	bld	r18, 0
    push    x4              ;[14] == phase
 194:	5f 93       	push	r21
;   [---]                   ;[15]
    push    cnt             ;[16]
 196:	3f 93       	push	r19
;   [---]                   ;[17]
    ldi     phase, 0        ;[18] [rx loop init]
 198:	50 e0       	ldi	r21, 0x00	; 0
    ldi     cnt, USB_BUFSIZE;[19] [rx loop init]
 19a:	3b e0       	ldi	r19, 0x0B	; 11
    rjmp    rxbit1          ;[20]
 19c:	65 c0       	rjmp	.+202    	; 0x268 <rxbit1>

0000019e <continueWithBit5>:
bit 7: jump, fixup bitstuff
; 87 [+ 2] cycles
------------------------------------------------------------------
*/
continueWithBit5:
    in      x2, USBIN       ;[055] <-- bit 5
 19e:	16 b3       	in	r17, 0x16	; 22
    eor     r0, x2          ;[056]
 1a0:	01 26       	eor	r0, r17
    or      phase, r0       ;[057]
 1a2:	50 29       	or	r21, r0
    sbrc    phase, USBMINUS ;[058]
 1a4:	53 fd       	sbrc	r21, 3
    lpm                     ;[059] optional nop3; modifies r0
 1a6:	c8 95       	lpm
    in      phase, USBIN    ;[060] <-- phase
 1a8:	56 b3       	in	r21, 0x16	; 22
    eor     x1, x2          ;[061]
 1aa:	01 27       	eor	r16, r17
    bst     x1, USBMINUS    ;[062]
 1ac:	03 fb       	bst	r16, 3
    bld     shift, 5        ;[063]
 1ae:	25 f9       	bld	r18, 5
    andi    shift, 0x3f     ;[064]
 1b0:	2f 73       	andi	r18, 0x3F	; 63
    in      x1, USBIN       ;[065] <-- bit 6
 1b2:	06 b3       	in	r16, 0x16	; 22
    breq    unstuff5        ;[066] *** unstuff escape
 1b4:	b1 f0       	breq	.+44     	; 0x1e2 <unstuff5>
    eor     phase, x1       ;[067]
 1b6:	50 27       	eor	r21, r16
    eor     x2, x1          ;[068]
 1b8:	10 27       	eor	r17, r16
    bst     x2, USBMINUS    ;[069]
 1ba:	13 fb       	bst	r17, 3
    bld     shift, 6        ;[070]
 1bc:	26 f9       	bld	r18, 6

000001be <didUnstuff6>:
didUnstuff6:                ;[   ]
    in      r0, USBIN       ;[071] <-- phase
 1be:	06 b2       	in	r0, 0x16	; 22
    cpi     shift, 0x02     ;[072]
 1c0:	22 30       	cpi	r18, 0x02	; 2
    brlo    unstuff6        ;[073] *** unstuff escape
 1c2:	f0 f0       	brcs	.+60     	; 0x200 <unstuff6>

000001c4 <didUnstuff5>:
didUnstuff5:                ;[   ]
    nop2                    ;[074]
 1c4:	00 c0       	rjmp	.+0      	; 0x1c6 <didUnstuff5+0x2>
;   [---]                   ;[075]
    in      x2, USBIN       ;[076] <-- bit 7
 1c6:	16 b3       	in	r17, 0x16	; 22
    eor     x1, x2          ;[077]
 1c8:	01 27       	eor	r16, r17
    bst     x1, USBMINUS    ;[078]
 1ca:	03 fb       	bst	r16, 3
    bld     shift, 7        ;[079]
 1cc:	27 f9       	bld	r18, 7

000001ce <didUnstuff7>:
didUnstuff7:                ;[   ]
    eor     r0, x2          ;[080]
 1ce:	01 26       	eor	r0, r17
    or      phase, r0       ;[081]
 1d0:	50 29       	or	r21, r0
    in      r0, USBIN       ;[082] <-- phase
 1d2:	06 b2       	in	r0, 0x16	; 22
    cpi     shift, 0x04     ;[083]
 1d4:	24 30       	cpi	r18, 0x04	; 4
    brsh    rxLoop          ;[084]
 1d6:	e8 f5       	brcc	.+122    	; 0x252 <rxLoop>

000001d8 <unstuff7>:
;   [---]                   ;[085]
unstuff7:                   ;[   ]
    andi    x3, ~0x80       ;[085]
 1d8:	4f 77       	andi	r20, 0x7F	; 127
    ori     shift, 0x80     ;[086]
 1da:	20 68       	ori	r18, 0x80	; 128
    in      x2, USBIN       ;[087] <-- sample stuffed bit 7
 1dc:	16 b3       	in	r17, 0x16	; 22
    nop                     ;[088]
 1de:	00 00       	nop
    rjmp    didUnstuff7     ;[089]
 1e0:	f6 cf       	rjmp	.-20     	; 0x1ce <didUnstuff7>

000001e2 <unstuff5>:
;   [---]                   ;[090]
                            ;[080]

unstuff5:                   ;[067]
    eor     phase, x1       ;[068]
 1e2:	50 27       	eor	r21, r16
    andi    x3, ~0x20       ;[069]
 1e4:	4f 7d       	andi	r20, 0xDF	; 223
    ori     shift, 0x20     ;[070]
 1e6:	20 62       	ori	r18, 0x20	; 32
    in      r0, USBIN       ;[071] <-- phase
 1e8:	06 b2       	in	r0, 0x16	; 22
    mov     x2, x1          ;[072]
 1ea:	10 2f       	mov	r17, r16
    nop                     ;[073]
 1ec:	00 00       	nop
    nop2                    ;[074]
 1ee:	00 c0       	rjmp	.+0      	; 0x1f0 <unstuff5+0xe>
;   [---]                   ;[075]
    in      x1, USBIN       ;[076] <-- bit 6
 1f0:	06 b3       	in	r16, 0x16	; 22
    eor     r0, x1          ;[077]
 1f2:	00 26       	eor	r0, r16
    or      phase, r0       ;[078]
 1f4:	50 29       	or	r21, r0
    eor     x2, x1          ;[079]
 1f6:	10 27       	eor	r17, r16
    bst     x2, USBMINUS    ;[080]
 1f8:	13 fb       	bst	r17, 3
    bld     shift, 6        ;[081] no need to check bitstuffing, we just had one
 1fa:	26 f9       	bld	r18, 6
    in      r0, USBIN       ;[082] <-- phase
 1fc:	06 b2       	in	r0, 0x16	; 22
    rjmp    didUnstuff5     ;[083]
 1fe:	e2 cf       	rjmp	.-60     	; 0x1c4 <didUnstuff5>

00000200 <unstuff6>:
;   [---]                   ;[084]
                            ;[074]

unstuff6:                   ;[074]
    andi    x3, ~0x40       ;[075]
 200:	4f 7b       	andi	r20, 0xBF	; 191
    in      x1, USBIN       ;[076] <-- bit 6 again
 202:	06 b3       	in	r16, 0x16	; 22
    ori     shift, 0x40     ;[077]
 204:	20 64       	ori	r18, 0x40	; 64
    nop2                    ;[078]
 206:	00 c0       	rjmp	.+0      	; 0x208 <unstuff6+0x8>
;   [---]                   ;[079]
    rjmp    didUnstuff6     ;[080]
 208:	da cf       	rjmp	.-76     	; 0x1be <didUnstuff6>

0000020a <unstuff0>:
;   [---]                   ;[081]
                            ;[071]

unstuff0:                   ;[013]
    eor     r0, x2          ;[014]
 20a:	01 26       	eor	r0, r17
    or      phase, r0       ;[015]
 20c:	50 29       	or	r21, r0
    andi    x2, USBMASK     ;[016] check for SE0
 20e:	18 71       	andi	r17, 0x18	; 24
    in      r0, USBIN       ;[017] <-- phase
 210:	06 b2       	in	r0, 0x16	; 22
    breq    didUnstuff0     ;[018] direct jump to se0 would be too long
 212:	69 f1       	breq	.+90     	; 0x26e <didUnstuff0>
    andi    x3, ~0x01       ;[019]
 214:	4e 7f       	andi	r20, 0xFE	; 254
    ori     shift, 0x01     ;[020]
 216:	21 60       	ori	r18, 0x01	; 1
    mov     x1, x2          ;[021] mov existing sample
 218:	01 2f       	mov	r16, r17
    in      x2, USBIN       ;[022] <-- bit 1 again
 21a:	16 b3       	in	r17, 0x16	; 22
    rjmp    didUnstuff0     ;[023]
 21c:	28 c0       	rjmp	.+80     	; 0x26e <didUnstuff0>

0000021e <unstuff1>:
;   [---]                   ;[024]
                            ;[014]

unstuff1:                   ;[024]
    eor     r0, x1          ;[025]
 21e:	00 26       	eor	r0, r16
    or      phase, r0       ;[026]
 220:	50 29       	or	r21, r0
    andi    x3, ~0x02       ;[027]
 222:	4d 7f       	andi	r20, 0xFD	; 253
    in      r0, USBIN       ;[028] <-- phase
 224:	06 b2       	in	r0, 0x16	; 22
    ori     shift, 0x02     ;[029]
 226:	22 60       	ori	r18, 0x02	; 2
    mov     x2, x1          ;[030]
 228:	10 2f       	mov	r17, r16
    rjmp    didUnstuff1     ;[031]
 22a:	29 c0       	rjmp	.+82     	; 0x27e <didUnstuff1>

0000022c <unstuff2>:
;   [---]                   ;[032]
                            ;[022]

unstuff2:                   ;[035]
    eor     r0, x2          ;[036]
 22c:	01 26       	eor	r0, r17
    or      phase, r0       ;[037]
 22e:	50 29       	or	r21, r0
    andi    x3, ~0x04       ;[038]
 230:	4b 7f       	andi	r20, 0xFB	; 251
    in      r0, USBIN       ;[039] <-- phase
 232:	06 b2       	in	r0, 0x16	; 22
    ori     shift, 0x04     ;[040]
 234:	24 60       	ori	r18, 0x04	; 4
    mov     x1, x2          ;[041]
 236:	01 2f       	mov	r16, r17
    rjmp    didUnstuff2     ;[042]
 238:	2d c0       	rjmp	.+90     	; 0x294 <didUnstuff2>

0000023a <unstuff3>:
;   [---]                   ;[043]
                            ;[033]

unstuff3:                   ;[043]
    in      x2, USBIN       ;[044] <-- bit 3 again
 23a:	16 b3       	in	r17, 0x16	; 22
    eor     r0, x2          ;[045]
 23c:	01 26       	eor	r0, r17
    or      phase, r0       ;[046]
 23e:	50 29       	or	r21, r0
    andi    x3, ~0x08       ;[047]
 240:	47 7f       	andi	r20, 0xF7	; 247
    ori     shift, 0x08     ;[048]
 242:	28 60       	ori	r18, 0x08	; 8
    nop                     ;[049]
 244:	00 00       	nop
    in      r0, USBIN       ;[050] <-- phase
 246:	06 b2       	in	r0, 0x16	; 22
    rjmp    didUnstuff3     ;[051]
 248:	2e c0       	rjmp	.+92     	; 0x2a6 <didUnstuff3>

0000024a <unstuff4>:
;   [---]                   ;[052]
                            ;[042]

unstuff4:                   ;[053]
    andi    x3, ~0x10       ;[054]
 24a:	4f 7e       	andi	r20, 0xEF	; 239
    in      x1, USBIN       ;[055] <-- bit 4 again
 24c:	06 b3       	in	r16, 0x16	; 22
    ori     shift, 0x10     ;[056]
 24e:	20 61       	ori	r18, 0x10	; 16
    rjmp    didUnstuff4     ;[057]
 250:	30 c0       	rjmp	.+96     	; 0x2b2 <didUnstuff4>

00000252 <rxLoop>:
;   [---]                   ;[058]
                            ;[048]

rxLoop:                     ;[085]
    eor     x3, shift       ;[086] reconstruct: x3 is 0 at bit locations we changed, 1 at others
 252:	42 27       	eor	r20, r18
    in      x1, USBIN       ;[000] <-- bit 0
 254:	06 b3       	in	r16, 0x16	; 22
    st      y+, x3          ;[001]
 256:	49 93       	st	Y+, r20
;   [---]                   ;[002]
    eor     r0, x1          ;[003]
 258:	00 26       	eor	r0, r16
    or      phase, r0       ;[004]
 25a:	50 29       	or	r21, r0
    eor     x2, x1          ;[005]
 25c:	10 27       	eor	r17, r16
    in      r0, USBIN       ;[006] <-- phase
 25e:	06 b2       	in	r0, 0x16	; 22
    ser     x3              ;[007]
 260:	4f ef       	ldi	r20, 0xFF	; 255
    bst     x2, USBMINUS    ;[008]
 262:	13 fb       	bst	r17, 3
    bld     shift, 0        ;[009]
 264:	20 f9       	bld	r18, 0
    andi    shift, 0xf9     ;[010]
 266:	29 7f       	andi	r18, 0xF9	; 249

00000268 <rxbit1>:
rxbit1:                     ;[   ]
    in      x2, USBIN       ;[011] <-- bit 1
 268:	16 b3       	in	r17, 0x16	; 22
    breq    unstuff0        ;[012] *** unstuff escape
 26a:	79 f2       	breq	.-98     	; 0x20a <unstuff0>
    andi    x2, USBMASK     ;[013] SE0 check for bit 1
 26c:	18 71       	andi	r17, 0x18	; 24

0000026e <didUnstuff0>:
didUnstuff0:                ;[   ] Z only set if we detected SE0 in bitstuff
    breq    se0             ;[014]
 26e:	59 f1       	breq	.+86     	; 0x2c6 <se0>
    eor     r0, x2          ;[015]
 270:	01 26       	eor	r0, r17
    or      phase, r0       ;[016]
 272:	50 29       	or	r21, r0
    in      r0, USBIN       ;[017] <-- phase
 274:	06 b2       	in	r0, 0x16	; 22
    eor     x1, x2          ;[018]
 276:	01 27       	eor	r16, r17
    bst     x1, USBMINUS    ;[019]
 278:	03 fb       	bst	r16, 3
    bld     shift, 1        ;[020]
 27a:	21 f9       	bld	r18, 1
    andi    shift, 0xf3     ;[021]
 27c:	23 7f       	andi	r18, 0xF3	; 243

0000027e <didUnstuff1>:
didUnstuff1:                ;[   ]
    in      x1, USBIN       ;[022] <-- bit 2
 27e:	06 b3       	in	r16, 0x16	; 22
    breq    unstuff1        ;[023] *** unstuff escape
 280:	71 f2       	breq	.-100    	; 0x21e <unstuff1>
    eor     r0, x1          ;[024]
 282:	00 26       	eor	r0, r16
    or      phase, r0       ;[025]
 284:	50 29       	or	r21, r0
    subi    cnt, 1          ;[026] overflow check
 286:	31 50       	subi	r19, 0x01	; 1
    brcs    overflow        ;[027]
 288:	d0 f0       	brcs	.+52     	; 0x2be <overflow>
    in      r0, USBIN       ;[028] <-- phase
 28a:	06 b2       	in	r0, 0x16	; 22
    eor     x2, x1          ;[029]
 28c:	10 27       	eor	r17, r16
    bst     x2, USBMINUS    ;[030]
 28e:	13 fb       	bst	r17, 3
    bld     shift, 2        ;[031]
 290:	22 f9       	bld	r18, 2
    andi    shift, 0xe7     ;[032]
 292:	27 7e       	andi	r18, 0xE7	; 231

00000294 <didUnstuff2>:
didUnstuff2:                ;[   ]
    in      x2, USBIN       ;[033] <-- bit 3
 294:	16 b3       	in	r17, 0x16	; 22
    breq    unstuff2        ;[034] *** unstuff escape
 296:	51 f2       	breq	.-108    	; 0x22c <unstuff2>
    eor     r0, x2          ;[035]
 298:	01 26       	eor	r0, r17
    or      phase, r0       ;[036]
 29a:	50 29       	or	r21, r0
    eor     x1, x2          ;[037]
 29c:	01 27       	eor	r16, r17
    bst     x1, USBMINUS    ;[038]
 29e:	03 fb       	bst	r16, 3
    in      r0, USBIN       ;[039] <-- phase
 2a0:	06 b2       	in	r0, 0x16	; 22
    bld     shift, 3        ;[040]
 2a2:	23 f9       	bld	r18, 3
    andi    shift, 0xcf     ;[041]
 2a4:	2f 7c       	andi	r18, 0xCF	; 207

000002a6 <didUnstuff3>:
didUnstuff3:                ;[   ]
    breq    unstuff3        ;[042] *** unstuff escape
 2a6:	49 f2       	breq	.-110    	; 0x23a <unstuff3>
    nop                     ;[043]
 2a8:	00 00       	nop
    in      x1, USBIN       ;[044] <-- bit 4
 2aa:	06 b3       	in	r16, 0x16	; 22
    eor     x2, x1          ;[045]
 2ac:	10 27       	eor	r17, r16
    bst     x2, USBMINUS    ;[046]
 2ae:	13 fb       	bst	r17, 3
    bld     shift, 4        ;[047]
 2b0:	24 f9       	bld	r18, 4

000002b2 <didUnstuff4>:
didUnstuff4:                ;[   ]
    eor     r0, x1          ;[048]
 2b2:	00 26       	eor	r0, r16
    or      phase, r0       ;[049]
 2b4:	50 29       	or	r21, r0
    in      r0, USBIN       ;[050] <-- phase
 2b6:	06 b2       	in	r0, 0x16	; 22
    andi    shift, 0x9f     ;[051]
 2b8:	2f 79       	andi	r18, 0x9F	; 159
    breq    unstuff4        ;[052] *** unstuff escape
 2ba:	39 f2       	breq	.-114    	; 0x24a <unstuff4>
    rjmp    continueWithBit5;[053]
 2bc:	70 cf       	rjmp	.-288    	; 0x19e <continueWithBit5>

000002be <overflow>:
*/

#define token   x1

overflow:
    ldi     x2, 1<<USB_INTR_PENDING_BIT
 2be:	10 e2       	ldi	r17, 0x20	; 32
    USB_STORE_PENDING(x2)       ; clear any pending interrupts
 2c0:	1a bf       	out	0x3a, r17	; 58

000002c2 <ignorePacket>:
ignorePacket:
    clr     token
 2c2:	00 27       	eor	r16, r16
    rjmp    storeTokenAndReturn
 2c4:	19 c0       	rjmp	.+50     	; 0x2f8 <handleSetupOrOut>

000002c6 <se0>:
; Processing of received packet (numbers in brackets are cycles after center of SE0)
;----------------------------------------------------------------------------
;This is the only non-error exit point for the software receiver loop
;we don't check any CRCs here because there is no time left.
se0:
    subi    cnt, USB_BUFSIZE    ;[5]
 2c6:	3b 50       	subi	r19, 0x0B	; 11
    neg     cnt                 ;[6]
 2c8:	31 95       	neg	r19
    sub     YL, cnt             ;[7]
 2ca:	c3 1b       	sub	r28, r19
    sbci    YH, 0               ;[8]
 2cc:	d0 40       	sbci	r29, 0x00	; 0
    ldi     x2, 1<<USB_INTR_PENDING_BIT ;[9]
 2ce:	10 e2       	ldi	r17, 0x20	; 32
    USB_STORE_PENDING(x2)       ;[10] clear pending intr and check flag later. SE0 should be over.
 2d0:	1a bf       	out	0x3a, r17	; 58
    ld      token, y            ;[11]
 2d2:	08 81       	ld	r16, Y
    cpi     token, USBPID_DATA0 ;[13]
 2d4:	03 3c       	cpi	r16, 0xC3	; 195
    breq    handleData          ;[14]
 2d6:	09 f1       	breq	.+66     	; 0x31a <handleData>
    cpi     token, USBPID_DATA1 ;[15]
 2d8:	0b 34       	cpi	r16, 0x4B	; 75
    breq    handleData          ;[16]
 2da:	f9 f0       	breq	.+62     	; 0x31a <handleData>
    lds     shift, usbDeviceAddr;[17]
 2dc:	20 91 89 00 	lds	r18, 0x0089
    ldd     x2, y+1             ;[19] ADDR and 1 bit endpoint number
 2e0:	19 81       	ldd	r17, Y+1	; 0x01
    lsl     x2                  ;[21] shift out 1 bit endpoint number
 2e2:	11 0f       	add	r17, r17
    cpse    x2, shift           ;[22]
 2e4:	12 13       	cpse	r17, r18
    rjmp    ignorePacket        ;[23]
 2e6:	ed cf       	rjmp	.-38     	; 0x2c2 <ignorePacket>
/* only compute endpoint number in x3 if required later */
#if USB_CFG_HAVE_INTRIN_ENDPOINT || USB_CFG_IMPLEMENT_FN_WRITEOUT
    ldd     x3, y+2             ;[24] endpoint number + crc
 2e8:	4a 81       	ldd	r20, Y+2	; 0x02
    rol     x3                  ;[26] shift in LSB of endpoint
 2ea:	44 1f       	adc	r20, r20
#endif
    cpi     token, USBPID_IN    ;[27]
 2ec:	09 36       	cpi	r16, 0x69	; 105
    breq    handleIn            ;[28]
 2ee:	51 f1       	breq	.+84     	; 0x344 <handleIn>
    cpi     token, USBPID_SETUP ;[29]
 2f0:	0d 32       	cpi	r16, 0x2D	; 45
    breq    handleSetupOrOut    ;[30]
 2f2:	11 f0       	breq	.+4      	; 0x2f8 <handleSetupOrOut>
    cpi     token, USBPID_OUT   ;[31]
 2f4:	01 3e       	cpi	r16, 0xE1	; 225
    brne    ignorePacket        ;[32] must be ack, nak or whatever
 2f6:	29 f7       	brne	.-54     	; 0x2c2 <ignorePacket>

000002f8 <handleSetupOrOut>:
    andi    x3, 0xf             ;[32]
    breq    storeTokenAndReturn ;[33]
    mov     token, x3           ;[34] indicate that this is endpoint x OUT
#endif
storeTokenAndReturn:
    sts     usbCurrentTok, token;[35]
 2f8:	00 93 90 00 	sts	0x0090, r16

000002fc <doReturn>:
doReturn:
    POP_STANDARD                ;[37] 12...16 cycles
 2fc:	3f 91       	pop	r19
 2fe:	5f 91       	pop	r21
 300:	4f 91       	pop	r20
 302:	1f 91       	pop	r17
 304:	0f 91       	pop	r16
 306:	2f 91       	pop	r18
 308:	df 91       	pop	r29
 30a:	0f 90       	pop	r0
    USB_LOAD_PENDING(YL)        ;[49]
 30c:	ca b7       	in	r28, 0x3a	; 58
    sbrc    YL, USB_INTR_PENDING_BIT;[50] check whether data is already arriving
 30e:	c5 fd       	sbrc	r28, 5
    rjmp    waitForJ            ;[51] save the pops and pushes -- a new interrupt is already pending
 310:	1c cf       	rjmp	.-456    	; 0x14a <waitForJ>

00000312 <sofError>:
sofError:
    POP_RETI                    ;macro call
 312:	cf 91       	pop	r28
 314:	cf bf       	out	0x3f, r28	; 63
 316:	cf 91       	pop	r28
    reti
 318:	18 95       	reti

0000031a <handleData>:

handleData:
    lds     token, usbCurrentTok;[18]
 31a:	00 91 90 00 	lds	r16, 0x0090
    tst     token               ;[20]
 31e:	00 23       	and	r16, r16
    breq    doReturn            ;[21]
 320:	69 f3       	breq	.-38     	; 0x2fc <doReturn>
    lds     x2, usbRxLen        ;[22]
 322:	10 91 8e 00 	lds	r17, 0x008E
    tst     x2                  ;[24]
 326:	11 23       	and	r17, r17
    brne    sendNakAndReti      ;[25]
 328:	79 f5       	brne	.+94     	; 0x388 <sendNakAndReti>
; 2006-03-11: The following two lines fix a problem where the device was not
; recognized if usbPoll() was called less frequently than once every 4 ms.
    cpi     cnt, 4              ;[26] zero sized data packets are status phase only -- ignore and ack
 32a:	34 30       	cpi	r19, 0x04	; 4
    brmi    sendAckAndReti      ;[27] keep rx buffer clean -- we must not NAK next SETUP
 32c:	7a f1       	brmi	.+94     	; 0x38c <sendAckAndReti>
    sts     usbRxLen, cnt       ;[28] store received data, swap buffers
 32e:	30 93 8e 00 	sts	0x008E, r19
    sts     usbRxToken, token   ;[30]
 332:	00 93 8a 00 	sts	0x008A, r16
    lds     x2, usbInputBufOffset;[32] swap buffers
 336:	10 91 8b 00 	lds	r17, 0x008B
    ldi     cnt, USB_BUFSIZE    ;[34]
 33a:	3b e0       	ldi	r19, 0x0B	; 11
    sub     cnt, x2             ;[35]
 33c:	31 1b       	sub	r19, r17
    sts     usbInputBufOffset, cnt;[36] buffers now swapped
 33e:	30 93 8b 00 	sts	0x008B, r19
    rjmp    sendAckAndReti      ;[38] 40 + 17 = 57 until SOP
 342:	24 c0       	rjmp	.+72     	; 0x38c <sendAckAndReti>

00000344 <handleIn>:

handleIn:
;We don't send any data as long as the C code has not processed the current
;input data and potentially updated the output data. That's more efficient
;in terms of code size than clearing the tx buffers when a packet is received.
    lds     x1, usbRxLen        ;[30]
 344:	00 91 8e 00 	lds	r16, 0x008E
    cpi     x1, 1               ;[32] negative values are flow control, 0 means "buffer free"
 348:	01 30       	cpi	r16, 0x01	; 1
    brge    sendNakAndReti      ;[33] unprocessed input packet?
 34a:	f4 f4       	brge	.+60     	; 0x388 <sendNakAndReti>
    ldi     x1, USBPID_NAK      ;[34] prepare value for usbTxLen
 34c:	0a e5       	ldi	r16, 0x5A	; 90
#if USB_CFG_HAVE_INTRIN_ENDPOINT
    andi    x3, 0xf             ;[35] x3 contains endpoint
 34e:	4f 70       	andi	r20, 0x0F	; 15
    brne    handleIn1           ;[36]
 350:	49 f4       	brne	.+18     	; 0x364 <handleIn1>
#endif
    lds     cnt, usbTxLen       ;[37]
 352:	30 91 65 00 	lds	r19, 0x0065
    sbrc    cnt, 4              ;[39] all handshake tokens have bit 4 set
 356:	34 fd       	sbrc	r19, 4
    rjmp    sendCntAndReti      ;[40] 42 + 16 = 58 until SOP
 358:	1a c0       	rjmp	.+52     	; 0x38e <sendCntAndReti>
    sts     usbTxLen, x1        ;[41] x1 == USBPID_NAK from above
 35a:	00 93 65 00 	sts	0x0065, r16
    ldi     YL, lo8(usbTxBuf)   ;[43]
 35e:	c3 e7       	ldi	r28, 0x73	; 115
    ldi     YH, hi8(usbTxBuf)   ;[44]
 360:	d0 e0       	ldi	r29, 0x00	; 0
    rjmp    usbSendAndReti      ;[45] 57 + 12 = 59 until SOP
 362:	19 c0       	rjmp	.+50     	; 0x396 <usbSendAndReti>

00000364 <handleIn1>:
#if USB_CFG_HAVE_INTRIN_ENDPOINT3
; 2006-06-10 as suggested by O.Tamura: support second INTR IN / BULK IN endpoint
    cpi     x3, USB_CFG_EP3_NUMBER;[38]
    breq    handleIn3           ;[39]
#endif
    lds     cnt, usbTxLen1      ;[40]
 364:	30 91 66 00 	lds	r19, 0x0066
    sbrc    cnt, 4              ;[42] all handshake tokens have bit 4 set
 368:	34 fd       	sbrc	r19, 4
    rjmp    sendCntAndReti      ;[43] 47 + 16 = 63 until SOP
 36a:	11 c0       	rjmp	.+34     	; 0x38e <sendCntAndReti>
    sts     usbTxLen1, x1       ;[44] x1 == USBPID_NAK from above
 36c:	00 93 66 00 	sts	0x0066, r16
    ldi     YL, lo8(usbTxBuf1)  ;[46]
 370:	ce e7       	ldi	r28, 0x7E	; 126
    ldi     YH, hi8(usbTxBuf1)  ;[47]
 372:	d0 e0       	ldi	r29, 0x00	; 0
    rjmp    usbSendAndReti      ;[48] 50 + 12 = 62 until SOP
 374:	10 c0       	rjmp	.+32     	; 0x396 <usbSendAndReti>

00000376 <bitstuff7>:
; J = (D+ = 0), (D- = 1)
; K = (D+ = 1), (D- = 0)
; Spec allows 7.5 bit times from EOP to SOP for replies

bitstuff7:
    eor     x1, x4          ;[4]
 376:	05 27       	eor	r16, r21
    ldi     x2, 0           ;[5]
 378:	10 e0       	ldi	r17, 0x00	; 0
    nop2                    ;[6] C is zero (brcc)
 37a:	00 c0       	rjmp	.+0      	; 0x37c <bitstuff7+0x6>
    rjmp    didStuff7       ;[8]
 37c:	21 c0       	rjmp	.+66     	; 0x3c0 <didStuff7>

0000037e <bitstuffN>:

bitstuffN:
    eor     x1, x4          ;[5]
 37e:	05 27       	eor	r16, r21
    ldi     x2, 0           ;[6]
 380:	10 e0       	ldi	r17, 0x00	; 0
    lpm                     ;[7] 3 cycle NOP, modifies r0
 382:	c8 95       	lpm
    out     USBOUT, x1      ;[10] <-- out
 384:	08 bb       	out	0x18, r16	; 24
    rjmp    didStuffN       ;[0]
 386:	14 c0       	rjmp	.+40     	; 0x3b0 <didStuffN>

00000388 <sendNakAndReti>:

#define bitStatus   x3

sendNakAndReti:
    ldi     cnt, USBPID_NAK ;[-19]
 388:	3a e5       	ldi	r19, 0x5A	; 90
    rjmp    sendCntAndReti  ;[-18]
 38a:	01 c0       	rjmp	.+2      	; 0x38e <sendCntAndReti>

0000038c <sendAckAndReti>:
sendAckAndReti:
    ldi     cnt, USBPID_ACK ;[-17]
 38c:	32 ed       	ldi	r19, 0xD2	; 210

0000038e <sendCntAndReti>:
sendCntAndReti:
    mov     r0, cnt         ;[-16]
 38e:	03 2e       	mov	r0, r19
    ldi     YL, 0           ;[-15] R0 address is 0
 390:	c0 e0       	ldi	r28, 0x00	; 0
    ldi     YH, 0           ;[-14]
 392:	d0 e0       	ldi	r29, 0x00	; 0
    ldi     cnt, 2          ;[-13]
 394:	32 e0       	ldi	r19, 0x02	; 2

00000396 <usbSendAndReti>:
;pointer to data in 'Y'
;number of bytes in 'cnt' -- including sync byte [range 2 ... 12]
;uses: x1...x4, shift, cnt, Y
;Numbers in brackets are time since first bit of sync pattern is sent
usbSendAndReti:             ; 12 cycles until SOP
    in      x2, USBDDR      ;[-12]
 396:	17 b3       	in	r17, 0x17	; 23
    ori     x2, USBMASK     ;[-11]
 398:	18 61       	ori	r17, 0x18	; 24
    sbi     USBOUT, USBMINUS;[-10] prepare idle state; D+ and D- must have been 0 (no pullups)
 39a:	c3 9a       	sbi	0x18, 3	; 24
    in      x1, USBOUT      ;[-8] port mirror for tx loop
 39c:	08 b3       	in	r16, 0x18	; 24
    out     USBDDR, x2      ;[-7] <- acquire bus
 39e:	17 bb       	out	0x17, r17	; 23
; need not init x2 (bitstuff history) because sync starts with 0
    ldi     x4, USBMASK     ;[-6] exor mask
 3a0:	58 e1       	ldi	r21, 0x18	; 24
    ldi     shift, 0x80     ;[-5] sync byte is first byte sent
 3a2:	20 e8       	ldi	r18, 0x80	; 128
    ldi     bitStatus, 0xff ;[-4] init bit loop counter, works for up to 12 bytes
 3a4:	4f ef       	ldi	r20, 0xFF	; 255

000003a6 <bitloop>:
byteloop:
bitloop:
    sbrs    shift, 0        ;[8] [-3]
 3a6:	20 ff       	sbrs	r18, 0
    eor     x1, x4          ;[9] [-2]
 3a8:	05 27       	eor	r16, r21
    out     USBOUT, x1      ;[10] [-1] <-- out
 3aa:	08 bb       	out	0x18, r16	; 24
    ror     shift           ;[0]
 3ac:	27 95       	ror	r18
    ror     x2              ;[1]
 3ae:	17 95       	ror	r17

000003b0 <didStuffN>:
didStuffN:
    cpi     x2, 0xfc        ;[2]
 3b0:	1c 3f       	cpi	r17, 0xFC	; 252
    brcc    bitstuffN       ;[3]
 3b2:	28 f7       	brcc	.-54     	; 0x37e <bitstuffN>
    nop                     ;[4]
 3b4:	00 00       	nop
    subi    bitStatus, 37   ;[5] 256 / 7 ~=~ 37
 3b6:	45 52       	subi	r20, 0x25	; 37
    brcc    bitloop         ;[6] when we leave the loop, bitStatus has almost the initial value
 3b8:	b0 f7       	brcc	.-20     	; 0x3a6 <bitloop>
    sbrs    shift, 0        ;[7]
 3ba:	20 ff       	sbrs	r18, 0
    eor     x1, x4          ;[8]
 3bc:	05 27       	eor	r16, r21
    ror     shift           ;[9]
 3be:	27 95       	ror	r18

000003c0 <didStuff7>:
didStuff7:
    out     USBOUT, x1      ;[10] <-- out
 3c0:	08 bb       	out	0x18, r16	; 24
    ror     x2              ;[0]
 3c2:	17 95       	ror	r17
    cpi     x2, 0xfc        ;[1]
 3c4:	1c 3f       	cpi	r17, 0xFC	; 252
    brcc    bitstuff7       ;[2]
 3c6:	b8 f6       	brcc	.-82     	; 0x376 <bitstuff7>
    ld      shift, y+       ;[3]
 3c8:	29 91       	ld	r18, Y+
    dec     cnt             ;[5]
 3ca:	3a 95       	dec	r19
    brne    byteloop        ;[6]
 3cc:	61 f7       	brne	.-40     	; 0x3a6 <bitloop>
;make SE0:
    cbr     x1, USBMASK     ;[7] prepare SE0 [spec says EOP may be 21 to 25 cycles]
 3ce:	07 7e       	andi	r16, 0xE7	; 231
    lds     x2, usbNewDeviceAddr;[8]
 3d0:	10 91 8f 00 	lds	r17, 0x008F
    lsl     x2              ;[10] we compare with left shifted address
 3d4:	11 0f       	add	r17, r17
    out     USBOUT, x1      ;[11] <-- out SE0 -- from now 2 bits = 22 cycles until bus idle
 3d6:	08 bb       	out	0x18, r16	; 24
;2006-03-06: moved transfer of new address to usbDeviceAddr from C-Code to asm:
;set address only after data packet was sent, not after handshake
    subi    YL, 2           ;[0] Only assign address on data packets, not ACK/NAK in r0
 3d8:	c2 50       	subi	r28, 0x02	; 2
    sbci    YH, 0           ;[1]
 3da:	d0 40       	sbci	r29, 0x00	; 0
    breq    skipAddrAssign  ;[2]
 3dc:	11 f0       	breq	.+4      	; 0x3e2 <skipAddrAssign>
    sts     usbDeviceAddr, x2; if not skipped: SE0 is one cycle longer
 3de:	10 93 89 00 	sts	0x0089, r17

000003e2 <skipAddrAssign>:
skipAddrAssign:
;end of usbDeviceAddress transfer
    ldi     x2, 1<<USB_INTR_PENDING_BIT;[4] int0 occurred during TX -- clear pending flag
 3e2:	10 e2       	ldi	r17, 0x20	; 32
    USB_STORE_PENDING(x2)   ;[5]
 3e4:	1a bf       	out	0x3a, r17	; 58
    ori     x1, USBIDLE     ;[6]
 3e6:	08 60       	ori	r16, 0x08	; 8
    in      x2, USBDDR      ;[7]
 3e8:	17 b3       	in	r17, 0x17	; 23
    cbr     x2, USBMASK     ;[8] set both pins to input
 3ea:	17 7e       	andi	r17, 0xE7	; 231
    mov     x3, x1          ;[9]
 3ec:	40 2f       	mov	r20, r16
    cbr     x3, USBMASK     ;[10] configure no pullup on both pins
 3ee:	47 7e       	andi	r20, 0xE7	; 231
    ldi     x4, 4           ;[11]
 3f0:	54 e0       	ldi	r21, 0x04	; 4

000003f2 <se0Delay>:
se0Delay:
    dec     x4              ;[12] [15] [18] [21]
 3f2:	5a 95       	dec	r21
    brne    se0Delay        ;[13] [16] [19] [22]
 3f4:	f1 f7       	brne	.-4      	; 0x3f2 <se0Delay>
    out     USBOUT, x1      ;[23] <-- out J (idle) -- end of SE0 (EOP signal)
 3f6:	08 bb       	out	0x18, r16	; 24
    out     USBDDR, x2      ;[24] <-- release bus now
 3f8:	17 bb       	out	0x17, r17	; 23
    out     USBOUT, x3      ;[25] <-- ensure no pull-up resistors are active
 3fa:	48 bb       	out	0x18, r20	; 24
    rjmp    doReturn
 3fc:	7f cf       	rjmp	.-258    	; 0x2fc <doReturn>

000003fe <prng>:
// -------------------------------------------------------------------------
// DonP 20080424
// Pretty good and fast pseudo-random number generator
// From Glen Worstell, in entry A3650 in CC AVR design contest
long int prng(long int seed)		// Call with seed value 1<= seed <= 0x7FFFFFFF-1
{
 3fe:	af 92       	push	r10
 400:	bf 92       	push	r11
 402:	cf 92       	push	r12
 404:	df 92       	push	r13
 406:	ef 92       	push	r14
 408:	ff 92       	push	r15
 40a:	0f 93       	push	r16
 40c:	1f 93       	push	r17
	// 0x7FFFFFFF is a magic number related to the prng function
	seed=(seed>>16) + ((seed<<15) & 0x7FFFFFFF) - (seed>>21) - ((seed<<10) & 0x7FFFFFFF);
 40e:	7b 01       	movw	r14, r22
 410:	8c 01       	movw	r16, r24
 412:	aa e0       	ldi	r26, 0x0A	; 10
 414:	ee 0c       	add	r14, r14
 416:	ff 1c       	adc	r15, r15
 418:	00 1f       	adc	r16, r16
 41a:	11 1f       	adc	r17, r17
 41c:	aa 95       	dec	r26
 41e:	d1 f7       	brne	.-12     	; 0x414 <prng+0x16>
 420:	2f ef       	ldi	r18, 0xFF	; 255
 422:	3f ef       	ldi	r19, 0xFF	; 255
 424:	4f ef       	ldi	r20, 0xFF	; 255
 426:	5f e7       	ldi	r21, 0x7F	; 127
 428:	e2 22       	and	r14, r18
 42a:	f3 22       	and	r15, r19
 42c:	04 23       	and	r16, r20
 42e:	15 23       	and	r17, r21
 430:	5b 01       	movw	r10, r22
 432:	6c 01       	movw	r12, r24
 434:	ff e0       	ldi	r31, 0x0F	; 15
 436:	aa 0c       	add	r10, r10
 438:	bb 1c       	adc	r11, r11
 43a:	cc 1c       	adc	r12, r12
 43c:	dd 1c       	adc	r13, r13
 43e:	fa 95       	dec	r31
 440:	d1 f7       	brne	.-12     	; 0x436 <prng+0x38>
 442:	a2 22       	and	r10, r18
 444:	b3 22       	and	r11, r19
 446:	c4 22       	and	r12, r20
 448:	d5 22       	and	r13, r21
 44a:	9b 01       	movw	r18, r22
 44c:	ac 01       	movw	r20, r24
 44e:	e5 e1       	ldi	r30, 0x15	; 21
 450:	55 95       	asr	r21
 452:	47 95       	ror	r20
 454:	37 95       	ror	r19
 456:	27 95       	ror	r18
 458:	ea 95       	dec	r30
 45a:	d1 f7       	brne	.-12     	; 0x450 <prng+0x52>
 45c:	a2 1a       	sub	r10, r18
 45e:	b3 0a       	sbc	r11, r19
 460:	c4 0a       	sbc	r12, r20
 462:	d5 0a       	sbc	r13, r21
 464:	bc 01       	movw	r22, r24
 466:	99 27       	eor	r25, r25
 468:	77 fd       	sbrc	r23, 7
 46a:	90 95       	com	r25
 46c:	89 2f       	mov	r24, r25
 46e:	a6 0e       	add	r10, r22
 470:	b7 1e       	adc	r11, r23
 472:	c8 1e       	adc	r12, r24
 474:	d9 1e       	adc	r13, r25
 476:	ae 18       	sub	r10, r14
 478:	bf 08       	sbc	r11, r15
 47a:	c0 0a       	sbc	r12, r16
 47c:	d1 0a       	sbc	r13, r17
	if( seed<0 ) 
 47e:	d7 fe       	sbrs	r13, 7
 480:	08 c0       	rjmp	.+16     	; 0x492 <prng+0x94>
		seed += 0x7FFFFFFF;
 482:	8f ef       	ldi	r24, 0xFF	; 255
 484:	9f ef       	ldi	r25, 0xFF	; 255
 486:	af ef       	ldi	r26, 0xFF	; 255
 488:	bf e7       	ldi	r27, 0x7F	; 127
 48a:	a8 0e       	add	r10, r24
 48c:	b9 1e       	adc	r11, r25
 48e:	ca 1e       	adc	r12, r26
 490:	db 1e       	adc	r13, r27
	return seed;
}
 492:	b5 01       	movw	r22, r10
 494:	c6 01       	movw	r24, r12
 496:	1f 91       	pop	r17
 498:	0f 91       	pop	r16
 49a:	ff 90       	pop	r15
 49c:	ef 90       	pop	r14
 49e:	df 90       	pop	r13
 4a0:	cf 90       	pop	r12
 4a2:	bf 90       	pop	r11
 4a4:	af 90       	pop	r10
 4a6:	08 95       	ret

000004a8 <buildReport>:

	// DonP 20080624
	// Random number generation
	long int x;
	// Use some value as a seed
	x = prng((long int)rand());
 4a8:	dd d2       	rcall	.+1466   	; 0xa64 <rand>
 4aa:	aa 27       	eor	r26, r26
 4ac:	97 fd       	sbrc	r25, 7
 4ae:	a0 95       	com	r26
 4b0:	ba 2f       	mov	r27, r26
 4b2:	bc 01       	movw	r22, r24
 4b4:	cd 01       	movw	r24, r26
 4b6:	a3 df       	rcall	.-186    	; 0x3fe <prng>
	// x is a 32 bit number
	x &= 0x0000FF00; // Axe all but these 8 bits
 4b8:	60 70       	andi	r22, 0x00	; 0
 4ba:	80 70       	andi	r24, 0x00	; 0
 4bc:	90 70       	andi	r25, 0x00	; 0
	x = (x >> 8); // Shift over to the LSB side
	// x should now be between 0 and 255
	// Using the indicated bits seems to work better
	// for lower values and seeds.
	x = (x / 32);	// x should be 0-7 now
 4be:	bd e0       	ldi	r27, 0x0D	; 13
 4c0:	95 95       	asr	r25
 4c2:	87 95       	ror	r24
 4c4:	77 95       	ror	r23
 4c6:	67 95       	ror	r22
 4c8:	ba 95       	dec	r27
 4ca:	d1 f7       	brne	.-12     	; 0x4c0 <buildReport+0x18>
	// 0x2A Backspace
	// 0x2C Space
	// 0x53 Numlock	
	// 0x2B Tab 	
	// 0x4C Delete	
	if( x == 0 )
 4cc:	61 15       	cp	r22, r1
 4ce:	71 05       	cpc	r23, r1
 4d0:	81 05       	cpc	r24, r1
 4d2:	91 05       	cpc	r25, r1
 4d4:	09 f4       	brne	.+2      	; 0x4d8 <buildReport+0x30>
 4d6:	4c c0       	rjmp	.+152    	; 0x570 <buildReport+0xc8>
		randomkey = 0x39;
	if( x == 1 )
 4d8:	61 30       	cpi	r22, 0x01	; 1
 4da:	71 05       	cpc	r23, r1
 4dc:	81 05       	cpc	r24, r1
 4de:	91 05       	cpc	r25, r1
 4e0:	11 f4       	brne	.+4      	; 0x4e6 <buildReport+0x3e>
 4e2:	29 e4       	ldi	r18, 0x49	; 73
 4e4:	14 c0       	rjmp	.+40     	; 0x50e <buildReport+0x66>
		randomkey = 0x49;
	if( x == 2 )
 4e6:	62 30       	cpi	r22, 0x02	; 2
 4e8:	71 05       	cpc	r23, r1
 4ea:	81 05       	cpc	r24, r1
 4ec:	91 05       	cpc	r25, r1
 4ee:	11 f4       	brne	.+4      	; 0x4f4 <buildReport+0x4c>
 4f0:	2a e2       	ldi	r18, 0x2A	; 42
 4f2:	14 c0       	rjmp	.+40     	; 0x51c <buildReport+0x74>
		randomkey = 0x2A;
	if( x == 3 )
 4f4:	63 30       	cpi	r22, 0x03	; 3
 4f6:	71 05       	cpc	r23, r1
 4f8:	81 05       	cpc	r24, r1
 4fa:	91 05       	cpc	r25, r1
 4fc:	d9 f1       	breq	.+118    	; 0x574 <buildReport+0xcc>
		randomkey = 0x2C;
	if( x == 4 )
 4fe:	64 30       	cpi	r22, 0x04	; 4
 500:	71 05       	cpc	r23, r1
 502:	81 05       	cpc	r24, r1
 504:	91 05       	cpc	r25, r1
 506:	11 f4       	brne	.+4      	; 0x50c <buildReport+0x64>
 508:	23 e5       	ldi	r18, 0x53	; 83
 50a:	15 c0       	rjmp	.+42     	; 0x536 <buildReport+0x8e>
 50c:	20 e0       	ldi	r18, 0x00	; 0
		randomkey = 0x53;
	if( x == 5 )
 50e:	65 30       	cpi	r22, 0x05	; 5
 510:	71 05       	cpc	r23, r1
 512:	81 05       	cpc	r24, r1
 514:	91 05       	cpc	r25, r1
 516:	11 f4       	brne	.+4      	; 0x51c <buildReport+0x74>
 518:	2b e2       	ldi	r18, 0x2B	; 43
 51a:	0d c0       	rjmp	.+26     	; 0x536 <buildReport+0x8e>
		randomkey = 0x2B;
	if( x == 6 )
 51c:	66 30       	cpi	r22, 0x06	; 6
 51e:	71 05       	cpc	r23, r1
 520:	81 05       	cpc	r24, r1
 522:	91 05       	cpc	r25, r1
 524:	11 f4       	brne	.+4      	; 0x52a <buildReport+0x82>
 526:	2c e4       	ldi	r18, 0x4C	; 76
 528:	06 c0       	rjmp	.+12     	; 0x536 <buildReport+0x8e>
		randomkey = 0x4C;
	if( x == 7 )
 52a:	67 30       	cpi	r22, 0x07	; 7
 52c:	71 05       	cpc	r23, r1
 52e:	81 05       	cpc	r24, r1
 530:	91 05       	cpc	r25, r1
 532:	09 f4       	brne	.+2      	; 0x536 <buildReport+0x8e>
 534:	29 e3       	ldi	r18, 0x39	; 57
		randomkey = 0x39;	// Caps Lock again to round it out
	// End DonP


    if(reportCount == 0)
 536:	30 91 6d 00 	lds	r19, 0x006D
 53a:	33 23       	and	r19, r19
 53c:	11 f0       	breq	.+4      	; 0x542 <buildReport+0x9a>
 53e:	80 e0       	ldi	r24, 0x00	; 0
 540:	0f c0       	rjmp	.+30     	; 0x560 <buildReport+0xb8>
		// present in one report, then absent from a subsequent one.
		// So if we sent 0x39 in the last one, let this next one be '0'.
		// We do this by only overriding when it's time for a report.
		// Otherwise it builds in the default '0' (empty) value.

		if( sendInitialCapsLock > 0 )
 542:	80 91 70 00 	lds	r24, 0x0070
 546:	88 23       	and	r24, r24
 548:	11 f4       	brne	.+4      	; 0x54e <buildReport+0xa6>
 54a:	82 2f       	mov	r24, r18
 54c:	09 c0       	rjmp	.+18     	; 0x560 <buildReport+0xb8>
			////////////////////////////////////////////////
			*/

			// We always enter this function 1 time right off the bat, so ignore it
			// if that's the case (actually, make it an empty report).
			if( sendInitialCapsLock!=3 )
 54e:	83 30       	cpi	r24, 0x03	; 3
 550:	11 f4       	brne	.+4      	; 0x556 <buildReport+0xae>
 552:	90 e0       	ldi	r25, 0x00	; 0
 554:	01 c0       	rjmp	.+2      	; 0x558 <buildReport+0xb0>
 556:	99 e3       	ldi	r25, 0x39	; 57
			else
			{
				randomkey = 0x00;
			}
			
			sendInitialCapsLock--;
 558:	81 50       	subi	r24, 0x01	; 1
 55a:	80 93 70 00 	sts	0x0070, r24
 55e:	89 2f       	mov	r24, r25

       	key = randomkey;
	}


	reportCount++;
 560:	3f 5f       	subi	r19, 0xFF	; 255
 562:	30 93 6d 00 	sts	0x006D, r19
    reportBuffer[0] = 0;    /* no modifiers */
 566:	10 92 6a 00 	sts	0x006A, r1
    reportBuffer[1] = key;
 56a:	80 93 6b 00 	sts	0x006B, r24
}
 56e:	08 95       	ret
 570:	29 e3       	ldi	r18, 0x39	; 57
 572:	cd cf       	rjmp	.-102    	; 0x50e <buildReport+0x66>
 574:	2c e2       	ldi	r18, 0x2C	; 44
 576:	df cf       	rjmp	.-66     	; 0x536 <buildReport+0x8e>

00000578 <usbFunctionSetup>:
/* ------------------------ interface to USB driver ------------------------ */
/* ------------------------------------------------------------------------- */

uchar	usbFunctionSetup(uchar data[8])
{
usbRequest_t    *rq = (void *)data;
 578:	fc 01       	movw	r30, r24

    usbMsgPtr = reportBuffer;
 57a:	8a e6       	ldi	r24, 0x6A	; 106
 57c:	90 e0       	ldi	r25, 0x00	; 0
 57e:	90 93 8d 00 	sts	0x008D, r25
 582:	80 93 8c 00 	sts	0x008C, r24
    if((rq->bmRequestType & USBRQ_TYPE_MASK) == USBRQ_TYPE_CLASS){    /* class request type */
 586:	80 81       	ld	r24, Z
 588:	80 76       	andi	r24, 0x60	; 96
 58a:	80 32       	cpi	r24, 0x20	; 32
 58c:	b9 f4       	brne	.+46     	; 0x5bc <usbFunctionSetup+0x44>
        if(rq->bRequest == USBRQ_HID_GET_REPORT){  /* wValue: ReportType (highbyte), ReportID (lowbyte) */
 58e:	81 81       	ldd	r24, Z+1	; 0x01
 590:	81 30       	cpi	r24, 0x01	; 1
 592:	19 f4       	brne	.+6      	; 0x59a <usbFunctionSetup+0x22>
            /* we only have one report type, so don't look at wValue */
            buildReport();
 594:	89 df       	rcall	.-238    	; 0x4a8 <buildReport>
 596:	82 e0       	ldi	r24, 0x02	; 2
 598:	08 95       	ret
            return sizeof(reportBuffer);
        }else if(rq->bRequest == USBRQ_HID_GET_IDLE){
 59a:	82 30       	cpi	r24, 0x02	; 2
 59c:	41 f4       	brne	.+16     	; 0x5ae <usbFunctionSetup+0x36>
            usbMsgPtr = &idleRate;
 59e:	8c e6       	ldi	r24, 0x6C	; 108
 5a0:	90 e0       	ldi	r25, 0x00	; 0
 5a2:	90 93 8d 00 	sts	0x008D, r25
 5a6:	80 93 8c 00 	sts	0x008C, r24
 5aa:	81 e0       	ldi	r24, 0x01	; 1
 5ac:	08 95       	ret
            return 1;
        }else if(rq->bRequest == USBRQ_HID_SET_IDLE){
 5ae:	8a 30       	cpi	r24, 0x0A	; 10
 5b0:	29 f4       	brne	.+10     	; 0x5bc <usbFunctionSetup+0x44>
            idleRate = rq->wValue.bytes[1];
 5b2:	83 81       	ldd	r24, Z+3	; 0x03
 5b4:	80 93 6c 00 	sts	0x006C, r24
 5b8:	80 e0       	ldi	r24, 0x00	; 0
 5ba:	08 95       	ret
 5bc:	80 e0       	ldi	r24, 0x00	; 0
        }
    }else{
        /* no vendor specific requests implemented */
    }
	return 0;
}
 5be:	08 95       	ret

000005c0 <main>:
/* ------------------------------------------------------------------------- */
/* --------------------------------- main ---------------------------------- */
/* ------------------------------------------------------------------------- */

int main(void)
{
 5c0:	1f 93       	push	r17
 5c2:	cf 93       	push	r28
 5c4:	df 93       	push	r29
uchar   i;
uchar   calibrationValue;

    calibrationValue = eeprom_read_byte(0); /* calibration value from last time */
 5c6:	80 e0       	ldi	r24, 0x00	; 0
 5c8:	90 e0       	ldi	r25, 0x00	; 0
 5ca:	5b d2       	rcall	.+1206   	; 0xa82 <__eerd_byte_tn85>
    if(calibrationValue != 0xff){
 5cc:	8f 3f       	cpi	r24, 0xFF	; 255
 5ce:	09 f0       	breq	.+2      	; 0x5d2 <main+0x12>
        OSCCAL = calibrationValue;
 5d0:	81 bf       	out	0x31, r24	; 49
    }
    odDebugInit();
    usbDeviceDisconnect();
 5d2:	bb 9a       	sbi	0x17, 3	; 23
 5d4:	20 e0       	ldi	r18, 0x00	; 0
    milliseconds can be achieved.
 */
void
_delay_loop_2(uint16_t __count)
{
	__asm__ volatile (
 5d6:	43 eb       	ldi	r20, 0xB3	; 179
 5d8:	51 ef       	ldi	r21, 0xF1	; 241
 5da:	ca 01       	movw	r24, r20
 5dc:	01 97       	sbiw	r24, 0x01	; 1
 5de:	f1 f7       	brne	.-4      	; 0x5dc <main+0x1c>
    for(i=0;i<20;i++){  /* 300 ms disconnect */
 5e0:	2f 5f       	subi	r18, 0xFF	; 255
 5e2:	24 31       	cpi	r18, 0x14	; 20
 5e4:	d1 f7       	brne	.-12     	; 0x5da <main+0x1a>
        _delay_ms(15);
    }
    usbDeviceConnect();
 5e6:	bb 98       	cbi	0x17, 3	; 23

    wdt_enable(WDTO_1S);
 5e8:	2e e0       	ldi	r18, 0x0E	; 14
 5ea:	88 e1       	ldi	r24, 0x18	; 24
 5ec:	90 e0       	ldi	r25, 0x00	; 0
 5ee:	0f b6       	in	r0, 0x3f	; 63
 5f0:	f8 94       	cli
 5f2:	a8 95       	wdr
 5f4:	81 bd       	out	0x21, r24	; 33
 5f6:	0f be       	out	0x3f, r0	; 63
 5f8:	21 bd       	out	0x21, r18	; 33

/* ------------------------------------------------------------------------- */

static void timerInit(void)
{
    TCCR1 = 0x0b;           /* select clock: 16.5M/1k -> overflow rate = 16.5M/256k = 62.94 Hz */
 5fa:	8b e0       	ldi	r24, 0x0B	; 11
 5fc:	80 bf       	out	0x30, r24	; 48
    usbDeviceConnect();

    wdt_enable(WDTO_1S);
    timerInit();
	//TimerDelay = 630; /* initial 10 second delay */
	TimerDelay = 200; /* initial ~3 second delay */
 5fe:	88 ec       	ldi	r24, 0xC8	; 200
 600:	90 e0       	ldi	r25, 0x00	; 0
 602:	90 93 6f 00 	sts	0x006F, r25
 606:	80 93 6e 00 	sts	0x006E, r24
	// Non-zero 'sendInitialCapsLock' means:
	// 1. Override key selection to be alternately the 'CapsLock' event, or an empty report.
	// 2. Override random interval delay (after initial 3 second delay) to be 1 second.
	// 3. Decrement the 'sendInitialCapsLock' value by 1.

	sendInitialCapsLock = 3; // DonP - set flag to override key selection this many times+1.
 60a:	83 e0       	ldi	r24, 0x03	; 3
 60c:	80 93 70 00 	sts	0x0070, r24
	// (+1 because buildreport runs at powerup once and we want to ignore that.)


    usbInit();
 610:	8b d0       	rcall	.+278    	; 0x728 <usbInit>
    sei();
 612:	78 94       	sei
{
	static unsigned int timerCnt;

    if(TIFR & (1 << TOV1))
	{
        TIFR = (1 << TOV1); /* clear overflow */
 614:	14 e0       	ldi	r17, 0x04	; 4
			// Actually only if it's greater than 1 otherwise the next event AFTER
			// the initial caps lock toggle is 1 second after the last toggle.
			// In other words if the flag is 1 the NEXT delay is what we want to be normal.
			// (Not the one after the flag is 0.)
			if( sendInitialCapsLock > 1)
				TimerDelay = 60;
 616:	cc e3       	ldi	r28, 0x3C	; 60
 618:	d0 e0       	ldi	r29, 0x00	; 0


    usbInit();
    sei();
    for(;;){    /* main event loop */
        wdt_reset();
 61a:	a8 95       	wdr
        usbPoll();
 61c:	b0 d0       	rcall	.+352    	; 0x77e <usbPoll>
		/* A USB keypress cycle is defined as a scancode being present in a report, and
		then absent from a later report. To press and release the Caps Lock key, instead of
		holding it down, we need to send the report with the Caps Lock scancode and
		then an empty report. */

        if(usbInterruptIsReady() && reportCount < 2){ /* we can send another key */
 61e:	80 91 66 00 	lds	r24, 0x0066
 622:	84 ff       	sbrs	r24, 4
 624:	09 c0       	rjmp	.+18     	; 0x638 <main+0x78>
 626:	80 91 6d 00 	lds	r24, 0x006D
 62a:	82 30       	cpi	r24, 0x02	; 2
 62c:	28 f4       	brcc	.+10     	; 0x638 <main+0x78>
            buildReport();
 62e:	3c df       	rcall	.-392    	; 0x4a8 <buildReport>
			usbSetInterrupt(reportBuffer, sizeof(reportBuffer));
 630:	8a e6       	ldi	r24, 0x6A	; 106
 632:	90 e0       	ldi	r25, 0x00	; 0
 634:	62 e0       	ldi	r22, 0x02	; 2
 636:	80 d0       	rcall	.+256    	; 0x738 <usbSetInterrupt>

static void timerPoll(void)
{
	static unsigned int timerCnt;

    if(TIFR & (1 << TOV1))
 638:	08 b6       	in	r0, 0x38	; 56
 63a:	02 fe       	sbrs	r0, 2
 63c:	ee cf       	rjmp	.-36     	; 0x61a <main+0x5a>
	{
        TIFR = (1 << TOV1); /* clear overflow */
 63e:	18 bf       	out	0x38, r17	; 56

		/* check for end of pseudorandom delay */
        if( ++timerCnt >= TimerDelay )	
 640:	80 91 68 00 	lds	r24, 0x0068
 644:	90 91 69 00 	lds	r25, 0x0069
 648:	01 96       	adiw	r24, 0x01	; 1
 64a:	90 93 69 00 	sts	0x0069, r25
 64e:	80 93 68 00 	sts	0x0068, r24
 652:	20 91 6e 00 	lds	r18, 0x006E
 656:	30 91 6f 00 	lds	r19, 0x006F
 65a:	82 17       	cp	r24, r18
 65c:	93 07       	cpc	r25, r19
 65e:	e8 f2       	brcs	.-70     	; 0x61a <main+0x5a>
		{
			TimerDelay = 2835 + rand();		/* 1/63s * 63 * 30 + 0...32767 */
 660:	01 d2       	rcall	.+1026   	; 0xa64 <rand>
 662:	8d 5e       	subi	r24, 0xED	; 237
 664:	94 4f       	sbci	r25, 0xF4	; 244
 666:	90 93 6f 00 	sts	0x006F, r25
 66a:	80 93 6e 00 	sts	0x006E, r24
			// DonP - ensure delay is overridden to ~1 second if this flag is set.
			// Actually only if it's greater than 1 otherwise the next event AFTER
			// the initial caps lock toggle is 1 second after the last toggle.
			// In other words if the flag is 1 the NEXT delay is what we want to be normal.
			// (Not the one after the flag is 0.)
			if( sendInitialCapsLock > 1)
 66e:	80 91 70 00 	lds	r24, 0x0070
 672:	82 30       	cpi	r24, 0x02	; 2
 674:	20 f0       	brcs	.+8      	; 0x67e <main+0xbe>
				TimerDelay = 60;
 676:	d0 93 6f 00 	sts	0x006F, r29
 67a:	c0 93 6e 00 	sts	0x006E, r28

			timerCnt = 0;
 67e:	10 92 69 00 	sts	0x0069, r1
 682:	10 92 68 00 	sts	0x0068, r1
			reportCount = 0; /* start report */
 686:	10 92 6d 00 	sts	0x006D, r1
 68a:	c7 cf       	rjmp	.-114    	; 0x61a <main+0x5a>

0000068c <usbEventResetReady>:
ATTiny25, ATTiny45, ATTiny85), it may be useful to search for the optimum in
both regions.
*/

void    usbEventResetReady(void)
{
 68c:	df 92       	push	r13
 68e:	ef 92       	push	r14
 690:	ff 92       	push	r15
 692:	0f 93       	push	r16
 694:	1f 93       	push	r17
 696:	cf 93       	push	r28
 698:	df 93       	push	r29
 69a:	10 e8       	ldi	r17, 0x80	; 128
 69c:	d1 2e       	mov	r13, r17
 69e:	00 e0       	ldi	r16, 0x00	; 0
 6a0:	ee 24       	eor	r14, r14
 6a2:	ff 24       	eor	r15, r15
uchar       trialValue = 0, optimumValue;
int         x, optimumDev, targetValue = (unsigned)(1499 * (double)F_CPU / 10.5e6 + 0.5);

    /* do a binary search: */
    do{
        OSCCAL = trialValue + step;
 6a4:	1d 2d       	mov	r17, r13
 6a6:	10 0f       	add	r17, r16
 6a8:	11 bf       	out	0x31, r17	; 49
        x = usbMeasureFrameLength();    /* proportional to current real frequency */
 6aa:	39 dd       	rcall	.-1422   	; 0x11e <usbMeasureFrameLength>
 6ac:	ec 01       	movw	r28, r24
        if(x < targetValue)             /* frequency still too low */
 6ae:	89 e0       	ldi	r24, 0x09	; 9
 6b0:	c4 33       	cpi	r28, 0x34	; 52
 6b2:	d8 07       	cpc	r29, r24
 6b4:	0c f0       	brlt	.+2      	; 0x6b8 <usbEventResetReady+0x2c>
 6b6:	10 2f       	mov	r17, r16
            trialValue += step;
        step >>= 1;
 6b8:	d6 94       	lsr	r13
 6ba:	08 94       	sec
 6bc:	e1 1c       	adc	r14, r1
 6be:	f1 1c       	adc	r15, r1
    }while(step > 0);
 6c0:	88 e0       	ldi	r24, 0x08	; 8
 6c2:	e8 16       	cp	r14, r24
 6c4:	f1 04       	cpc	r15, r1
 6c6:	11 f0       	breq	.+4      	; 0x6cc <usbEventResetReady+0x40>
 6c8:	01 2f       	mov	r16, r17
 6ca:	ec cf       	rjmp	.-40     	; 0x6a4 <usbEventResetReady+0x18>
    /* We have a precision of +/- 1 for optimum OSCCAL here */
    /* now do a neighborhood search for optimum value */
    optimumValue = trialValue;
    optimumDev = x; /* this is certainly far away from optimum */
    for(OSCCAL = trialValue - 1; OSCCAL <= trialValue + 1; OSCCAL++){
 6cc:	11 50       	subi	r17, 0x01	; 1
 6ce:	11 bf       	out	0x31, r17	; 49
 6d0:	1f 5f       	subi	r17, 0xFF	; 255
 6d2:	e1 2e       	mov	r14, r17
 6d4:	ff 24       	eor	r15, r15
 6d6:	08 94       	sec
 6d8:	e1 1c       	adc	r14, r1
 6da:	f1 1c       	adc	r15, r1
 6dc:	13 c0       	rjmp	.+38     	; 0x704 <usbEventResetReady+0x78>
        x = usbMeasureFrameLength() - targetValue;
 6de:	1f dd       	rcall	.-1474   	; 0x11e <usbMeasureFrameLength>
 6e0:	9c 01       	movw	r18, r24
 6e2:	24 53       	subi	r18, 0x34	; 52
 6e4:	39 40       	sbci	r19, 0x09	; 9
 6e6:	37 ff       	sbrs	r19, 7
 6e8:	03 c0       	rjmp	.+6      	; 0x6f0 <usbEventResetReady+0x64>
 6ea:	30 95       	com	r19
 6ec:	21 95       	neg	r18
 6ee:	3f 4f       	sbci	r19, 0xFF	; 255
        if(x < 0)
            x = -x;
        if(x < optimumDev){
 6f0:	2c 17       	cp	r18, r28
 6f2:	3d 07       	cpc	r19, r29
 6f4:	14 f0       	brlt	.+4      	; 0x6fa <usbEventResetReady+0x6e>
 6f6:	9e 01       	movw	r18, r28
 6f8:	01 c0       	rjmp	.+2      	; 0x6fc <usbEventResetReady+0x70>
            optimumDev = x;
            optimumValue = OSCCAL;
 6fa:	11 b7       	in	r17, 0x31	; 49
    }while(step > 0);
    /* We have a precision of +/- 1 for optimum OSCCAL here */
    /* now do a neighborhood search for optimum value */
    optimumValue = trialValue;
    optimumDev = x; /* this is certainly far away from optimum */
    for(OSCCAL = trialValue - 1; OSCCAL <= trialValue + 1; OSCCAL++){
 6fc:	81 b7       	in	r24, 0x31	; 49
 6fe:	8f 5f       	subi	r24, 0xFF	; 255
 700:	81 bf       	out	0x31, r24	; 49
 702:	e9 01       	movw	r28, r18
 704:	81 b7       	in	r24, 0x31	; 49
 706:	90 e0       	ldi	r25, 0x00	; 0
 708:	e8 16       	cp	r14, r24
 70a:	f9 06       	cpc	r15, r25
 70c:	44 f7       	brge	.-48     	; 0x6de <usbEventResetReady+0x52>
        if(x < optimumDev){
            optimumDev = x;
            optimumValue = OSCCAL;
        }
    }
    OSCCAL = optimumValue;
 70e:	11 bf       	out	0x31, r17	; 49
*/

void    usbEventResetReady(void)
{
    calibrateOscillator();
    eeprom_write_byte(0, OSCCAL);   /* store the calibrated value in EEPROM */
 710:	61 b7       	in	r22, 0x31	; 49
 712:	80 e0       	ldi	r24, 0x00	; 0
 714:	90 e0       	ldi	r25, 0x00	; 0
 716:	bd d1       	rcall	.+890    	; 0xa92 <__eewr_byte_tn85>
}
 718:	df 91       	pop	r29
 71a:	cf 91       	pop	r28
 71c:	1f 91       	pop	r17
 71e:	0f 91       	pop	r16
 720:	ff 90       	pop	r15
 722:	ef 90       	pop	r14
 724:	df 90       	pop	r13
 726:	08 95       	ret

00000728 <usbInit>:
/* ------------------------------------------------------------------------- */

USB_PUBLIC void usbInit(void)
{
#if USB_INTR_CFG_SET != 0
    USB_INTR_CFG |= USB_INTR_CFG_SET;
 728:	ac 9a       	sbi	0x15, 4	; 21
#endif
#if USB_INTR_CFG_CLR != 0
    USB_INTR_CFG &= ~(USB_INTR_CFG_CLR);
#endif
    USB_INTR_ENABLE |= (1 << USB_INTR_ENABLE_BIT);
 72a:	8b b7       	in	r24, 0x3b	; 59
 72c:	80 62       	ori	r24, 0x20	; 32
 72e:	8b bf       	out	0x3b, r24	; 59
/* ------------------------------------------------------------------------- */

static inline void  usbResetDataToggling(void)
{
#if USB_CFG_HAVE_INTRIN_ENDPOINT
    USB_SET_DATATOKEN1(USB_INITIAL_DATATOKEN);  /* reset data toggling for interrupt endpoint */
 730:	83 ec       	ldi	r24, 0xC3	; 195
 732:	80 93 7e 00 	sts	0x007E, r24
#if USB_INTR_CFG_CLR != 0
    USB_INTR_CFG &= ~(USB_INTR_CFG_CLR);
#endif
    USB_INTR_ENABLE |= (1 << USB_INTR_ENABLE_BIT);
    usbResetDataToggling();
}
 736:	08 95       	ret

00000738 <usbSetInterrupt>:

/* ------------------------------------------------------------------------- */

#if USB_CFG_HAVE_INTRIN_ENDPOINT
USB_PUBLIC void usbSetInterrupt(uchar *data, uchar len)
{
 738:	1f 93       	push	r17
 73a:	dc 01       	movw	r26, r24
 73c:	16 2f       	mov	r17, r22
#endif
#if 0   /* No runtime checks! Caller is responsible for valid data! */
    if(len > 8) /* interrupt transfers are limited to 8 bytes */
        len = 8;
#endif
    if(usbTxLen1 & 0x10){   /* packet buffer was empty */
 73e:	80 91 66 00 	lds	r24, 0x0066
 742:	84 ff       	sbrs	r24, 4
 744:	0a c0       	rjmp	.+20     	; 0x75a <usbSetInterrupt+0x22>
        usbTxBuf1[0] ^= USBPID_DATA0 ^ USBPID_DATA1;    /* toggle token */
 746:	80 91 7e 00 	lds	r24, 0x007E
 74a:	98 e8       	ldi	r25, 0x88	; 136
 74c:	89 27       	eor	r24, r25
 74e:	80 93 7e 00 	sts	0x007E, r24
 752:	91 2f       	mov	r25, r17
 754:	ef e7       	ldi	r30, 0x7F	; 127
 756:	f0 e0       	ldi	r31, 0x00	; 0
 758:	07 c0       	rjmp	.+14     	; 0x768 <usbSetInterrupt+0x30>
    }else{
        usbTxLen1 = USBPID_NAK; /* avoid sending outdated (overwritten) interrupt data */
 75a:	8a e5       	ldi	r24, 0x5A	; 90
 75c:	80 93 66 00 	sts	0x0066, r24
 760:	f8 cf       	rjmp	.-16     	; 0x752 <usbSetInterrupt+0x1a>
    }
    p = usbTxBuf1 + 1;
    for(i=len;i--;)
        *p++ = *data++;
 762:	8d 91       	ld	r24, X+
 764:	81 93       	st	Z+, r24
 766:	91 50       	subi	r25, 0x01	; 1
        usbTxBuf1[0] ^= USBPID_DATA0 ^ USBPID_DATA1;    /* toggle token */
    }else{
        usbTxLen1 = USBPID_NAK; /* avoid sending outdated (overwritten) interrupt data */
    }
    p = usbTxBuf1 + 1;
    for(i=len;i--;)
 768:	99 23       	and	r25, r25
 76a:	d9 f7       	brne	.-10     	; 0x762 <usbSetInterrupt+0x2a>
        *p++ = *data++;
    usbCrc16Append(&usbTxBuf1[1], len);
 76c:	8f e7       	ldi	r24, 0x7F	; 127
 76e:	90 e0       	ldi	r25, 0x00	; 0
 770:	61 2f       	mov	r22, r17
 772:	d1 dc       	rcall	.-1630   	; 0x116 <usbCrc16Append>
    usbTxLen1 = len + 4;    /* len must be given including sync byte */
 774:	1c 5f       	subi	r17, 0xFC	; 252
 776:	10 93 66 00 	sts	0x0066, r17
    DBG2(0x21, usbTxBuf1, len + 3);
}
 77a:	1f 91       	pop	r17
 77c:	08 95       	ret

0000077e <usbPoll>:
}

/* ------------------------------------------------------------------------- */

USB_PUBLIC void usbPoll(void)
{
 77e:	0f 93       	push	r16
 780:	1f 93       	push	r17
 782:	cf 93       	push	r28
 784:	df 93       	push	r29
schar   len;
uchar   i;

    if((len = usbRxLen) > 0){
 786:	90 91 8e 00 	lds	r25, 0x008E
 78a:	19 16       	cp	r1, r25
 78c:	0c f0       	brlt	.+2      	; 0x790 <usbPoll+0x12>
 78e:	b7 c0       	rjmp	.+366    	; 0x8fe <usbPoll+0x180>
 * need data integrity checks with this driver, check the CRC in your app
 * code and report errors back to the host. Since the ACK was already sent,
 * retries must be handled on application level.
 * unsigned crc = usbCrc16(buffer + 1, usbRxLen - 3);
 */
        usbProcessRx(usbRxBuf + USB_BUFSIZE + 1 - usbInputBufOffset, len - 3);
 790:	20 91 8b 00 	lds	r18, 0x008B
    if(usbRxToken < 0x10){  /* endpoint number in usbRxToken */
        usbFunctionWriteOut(data, len);
        return; /* no reply expected, hence no usbMsgPtr, usbMsgFlags, usbMsgLen set */
    }
#endif
    if(usbRxToken == (uchar)USBPID_SETUP){
 794:	80 91 8a 00 	lds	r24, 0x008A
 798:	8d 32       	cpi	r24, 0x2D	; 45
 79a:	09 f0       	breq	.+2      	; 0x79e <usbPoll+0x20>
 79c:	a6 c0       	rjmp	.+332    	; 0x8ea <usbPoll+0x16c>
        usbTxLen = USBPID_NAK;  /* abort pending transmit */
 79e:	8a e5       	ldi	r24, 0x5A	; 90
 7a0:	80 93 65 00 	sts	0x0065, r24
        if(len == 8){   /* Setup size must be always 8 bytes. Ignore otherwise. */
 7a4:	9b 30       	cpi	r25, 0x0B	; 11
 7a6:	09 f0       	breq	.+2      	; 0x7aa <usbPoll+0x2c>
 7a8:	a0 c0       	rjmp	.+320    	; 0x8ea <usbPoll+0x16c>
 * need data integrity checks with this driver, check the CRC in your app
 * code and report errors back to the host. Since the ACK was already sent,
 * retries must be handled on application level.
 * unsigned crc = usbCrc16(buffer + 1, usbRxLen - 3);
 */
        usbProcessRx(usbRxBuf + USB_BUFSIZE + 1 - usbInputBufOffset, len - 3);
 7aa:	cc e0       	ldi	r28, 0x0C	; 12
 7ac:	d0 e0       	ldi	r29, 0x00	; 0
 7ae:	c2 1b       	sub	r28, r18
 7b0:	d1 09       	sbc	r29, r1
 7b2:	ce 56       	subi	r28, 0x6E	; 110
 7b4:	df 4f       	sbci	r29, 0xFF	; 255
#endif
    if(usbRxToken == (uchar)USBPID_SETUP){
        usbTxLen = USBPID_NAK;  /* abort pending transmit */
        if(len == 8){   /* Setup size must be always 8 bytes. Ignore otherwise. */
            uchar type = rq->bmRequestType & USBRQ_TYPE_MASK;
            if(type == USBRQ_TYPE_STANDARD){
 7b6:	88 81       	ld	r24, Y
 7b8:	80 76       	andi	r24, 0x60	; 96
 7ba:	09 f0       	breq	.+2      	; 0x7be <usbPoll+0x40>
 7bc:	88 c0       	rjmp	.+272    	; 0x8ce <usbPoll+0x150>
                #define SET_REPLY_LEN(len)  replyLen = (len); usbMsgPtr = replyData
                /* This macro ensures that replyLen and usbMsgPtr are always set in the same way.
                 * That allows optimization of common code in if() branches */
                uchar *replyData = usbTxBuf + 9; /* there is 3 bytes free space at the end of the buffer */
                replyData[0] = 0;   /* common to USBRQ_GET_STATUS and USBRQ_GET_INTERFACE */
 7be:	10 92 7c 00 	sts	0x007C, r1
                if(rq->bRequest == USBRQ_GET_STATUS){           /* 0 */
 7c2:	89 81       	ldd	r24, Y+1	; 0x01
 7c4:	88 23       	and	r24, r24
 7c6:	59 f4       	brne	.+22     	; 0x7de <usbPoll+0x60>
#endif
#if USB_CFG_HAVE_INTRIN_ENDPOINT && USB_CFG_IMPLEMENT_HALT
                    if(recipient == USBRQ_RCPT_ENDPOINT && rq->wIndex.bytes[0] == 0x81)   /* request status for endpoint 1 */
                        replyData[0] = usbTxLen1 == USBPID_STALL;
#endif
                    replyData[1] = 0;
 7c8:	10 92 7d 00 	sts	0x007D, r1
                    SET_REPLY_LEN(2);
 7cc:	8c e7       	ldi	r24, 0x7C	; 124
 7ce:	90 e0       	ldi	r25, 0x00	; 0
 7d0:	90 93 8d 00 	sts	0x008D, r25
 7d4:	80 93 8c 00 	sts	0x008C, r24
 7d8:	90 e8       	ldi	r25, 0x80	; 128
 7da:	22 e0       	ldi	r18, 0x02	; 2
 7dc:	7f c0       	rjmp	.+254    	; 0x8dc <usbPoll+0x15e>
                }else if(rq->bRequest == USBRQ_SET_ADDRESS){    /* 5 */
 7de:	85 30       	cpi	r24, 0x05	; 5
 7e0:	21 f4       	brne	.+8      	; 0x7ea <usbPoll+0x6c>
                    usbNewDeviceAddr = rq->wValue.bytes[0];
 7e2:	8a 81       	ldd	r24, Y+2	; 0x02
 7e4:	80 93 8f 00 	sts	0x008F, r24
 7e8:	70 c0       	rjmp	.+224    	; 0x8ca <usbPoll+0x14c>
#ifdef USB_SET_ADDRESS_HOOK
                    USB_SET_ADDRESS_HOOK();
#endif
                }else if(rq->bRequest == USBRQ_GET_DESCRIPTOR){ /* 6 */
 7ea:	86 30       	cpi	r24, 0x06	; 6
 7ec:	09 f0       	breq	.+2      	; 0x7f0 <usbPoll+0x72>
 7ee:	52 c0       	rjmp	.+164    	; 0x894 <usbPoll+0x116>
                    flags = USB_FLG_MSGPTR_IS_ROM | USB_FLG_USE_DEFAULT_RW;
                    if(rq->wValue.bytes[1] == USBDESCR_DEVICE){ /* 1 */
 7f0:	8b 81       	ldd	r24, Y+3	; 0x03
 7f2:	81 30       	cpi	r24, 0x01	; 1
 7f4:	49 f4       	brne	.+18     	; 0x808 <usbPoll+0x8a>
                        GET_DESCRIPTOR(USB_CFG_DESCR_PROPS_DEVICE, usbDescriptorDevice)
 7f6:	8f e7       	ldi	r24, 0x7F	; 127
 7f8:	90 e0       	ldi	r25, 0x00	; 0
 7fa:	90 93 8d 00 	sts	0x008D, r25
 7fe:	80 93 8c 00 	sts	0x008C, r24
 802:	90 ec       	ldi	r25, 0xC0	; 192
 804:	22 e1       	ldi	r18, 0x12	; 18
 806:	6a c0       	rjmp	.+212    	; 0x8dc <usbPoll+0x15e>
                    }else if(rq->wValue.bytes[1] == USBDESCR_CONFIG){   /* 2 */
 808:	82 30       	cpi	r24, 0x02	; 2
 80a:	49 f4       	brne	.+18     	; 0x81e <usbPoll+0xa0>
                        GET_DESCRIPTOR(USB_CFG_DESCR_PROPS_CONFIGURATION, usbDescriptorConfiguration)
 80c:	81 e9       	ldi	r24, 0x91	; 145
 80e:	90 e0       	ldi	r25, 0x00	; 0
 810:	90 93 8d 00 	sts	0x008D, r25
 814:	80 93 8c 00 	sts	0x008C, r24
 818:	90 ec       	ldi	r25, 0xC0	; 192
 81a:	22 e2       	ldi	r18, 0x22	; 34
 81c:	5f c0       	rjmp	.+190    	; 0x8dc <usbPoll+0x15e>
                    }else if(rq->wValue.bytes[1] == USBDESCR_STRING){   /* 3 */
 81e:	83 30       	cpi	r24, 0x03	; 3
 820:	19 f5       	brne	.+70     	; 0x868 <usbPoll+0xea>
#if USB_CFG_DESCR_PROPS_STRINGS & USB_PROP_IS_DYNAMIC
                        if(USB_CFG_DESCR_PROPS_STRINGS & USB_PROP_IS_RAM)
                            flags &= ~USB_FLG_MSGPTR_IS_ROM;
                        replyLen = usbFunctionDescriptor(rq);
#else   /* USB_CFG_DESCR_PROPS_STRINGS & USB_PROP_IS_DYNAMIC */
                        if(rq->wValue.bytes[0] == 0){   /* descriptor index */
 822:	8a 81       	ldd	r24, Y+2	; 0x02
 824:	88 23       	and	r24, r24
 826:	49 f4       	brne	.+18     	; 0x83a <usbPoll+0xbc>
                            GET_DESCRIPTOR(USB_CFG_DESCR_PROPS_STRING_0, usbDescriptorString0)
 828:	81 e4       	ldi	r24, 0x41	; 65
 82a:	90 e0       	ldi	r25, 0x00	; 0
 82c:	90 93 8d 00 	sts	0x008D, r25
 830:	80 93 8c 00 	sts	0x008C, r24
 834:	90 ec       	ldi	r25, 0xC0	; 192
 836:	24 e0       	ldi	r18, 0x04	; 4
 838:	51 c0       	rjmp	.+162    	; 0x8dc <usbPoll+0x15e>
                        }else if(rq->wValue.bytes[0] == 1){
 83a:	81 30       	cpi	r24, 0x01	; 1
 83c:	49 f4       	brne	.+18     	; 0x850 <usbPoll+0xd2>
                            GET_DESCRIPTOR(USB_CFG_DESCR_PROPS_STRING_VENDOR, usbDescriptorStringVendor)
 83e:	85 e4       	ldi	r24, 0x45	; 69
 840:	90 e0       	ldi	r25, 0x00	; 0
 842:	90 93 8d 00 	sts	0x008D, r25
 846:	80 93 8c 00 	sts	0x008C, r24
 84a:	90 ec       	ldi	r25, 0xC0	; 192
 84c:	24 e2       	ldi	r18, 0x24	; 36
 84e:	46 c0       	rjmp	.+140    	; 0x8dc <usbPoll+0x15e>
                        }else if(rq->wValue.bytes[0] == 2){
 850:	82 30       	cpi	r24, 0x02	; 2
 852:	09 f0       	breq	.+2      	; 0x856 <usbPoll+0xd8>
 854:	41 c0       	rjmp	.+130    	; 0x8d8 <usbPoll+0x15a>
                            GET_DESCRIPTOR(USB_CFG_DESCR_PROPS_STRING_PRODUCT, usbDescriptorStringDevice)
 856:	89 e6       	ldi	r24, 0x69	; 105
 858:	90 e0       	ldi	r25, 0x00	; 0
 85a:	90 93 8d 00 	sts	0x008D, r25
 85e:	80 93 8c 00 	sts	0x008C, r24
 862:	90 ec       	ldi	r25, 0xC0	; 192
 864:	26 e1       	ldi	r18, 0x16	; 22
 866:	3a c0       	rjmp	.+116    	; 0x8dc <usbPoll+0x15e>
                        }else if(USB_CFG_DESCR_PROPS_UNKNOWN & USB_PROP_IS_DYNAMIC){
                            replyLen = usbFunctionDescriptor(rq);
                        }
#endif  /* USB_CFG_DESCR_PROPS_STRINGS & USB_PROP_IS_DYNAMIC */
#if USB_CFG_DESCR_PROPS_HID_REPORT  /* only support HID descriptors if enabled */
                    }else if(rq->wValue.bytes[1] == USBDESCR_HID){          /* 0x21 */
 868:	81 32       	cpi	r24, 0x21	; 33
 86a:	49 f4       	brne	.+18     	; 0x87e <usbPoll+0x100>
                        GET_DESCRIPTOR(USB_CFG_DESCR_PROPS_HID, usbDescriptorConfiguration + 18)
 86c:	83 ea       	ldi	r24, 0xA3	; 163
 86e:	90 e0       	ldi	r25, 0x00	; 0
 870:	90 93 8d 00 	sts	0x008D, r25
 874:	80 93 8c 00 	sts	0x008C, r24
 878:	90 ec       	ldi	r25, 0xC0	; 192
 87a:	29 e0       	ldi	r18, 0x09	; 9
 87c:	2f c0       	rjmp	.+94     	; 0x8dc <usbPoll+0x15e>
                    }else if(rq->wValue.bytes[1] == USBDESCR_HID_REPORT){   /* 0x22 */
 87e:	82 32       	cpi	r24, 0x22	; 34
 880:	59 f5       	brne	.+86     	; 0x8d8 <usbPoll+0x15a>
                        GET_DESCRIPTOR(USB_CFG_DESCR_PROPS_HID_REPORT, usbDescriptorHidReport)
 882:	8e e1       	ldi	r24, 0x1E	; 30
 884:	90 e0       	ldi	r25, 0x00	; 0
 886:	90 93 8d 00 	sts	0x008D, r25
 88a:	80 93 8c 00 	sts	0x008C, r24
 88e:	90 ec       	ldi	r25, 0xC0	; 192
 890:	23 e2       	ldi	r18, 0x23	; 35
 892:	24 c0       	rjmp	.+72     	; 0x8dc <usbPoll+0x15e>
#endif  /* USB_CFG_DESCR_PROPS_HID_REPORT */
                    }else if(USB_CFG_DESCR_PROPS_UNKNOWN & USB_PROP_IS_DYNAMIC){
                        replyLen = usbFunctionDescriptor(rq);
                    }
                }else if(rq->bRequest == USBRQ_GET_CONFIGURATION){  /* 8 */
 894:	88 30       	cpi	r24, 0x08	; 8
 896:	19 f4       	brne	.+6      	; 0x89e <usbPoll+0x120>
                    replyData = &usbConfiguration;  /* send current configuration value */
                    SET_REPLY_LEN(1);
 898:	81 e9       	ldi	r24, 0x91	; 145
 89a:	90 e0       	ldi	r25, 0x00	; 0
 89c:	0a c0       	rjmp	.+20     	; 0x8b2 <usbPoll+0x134>
                }else if(rq->bRequest == USBRQ_SET_CONFIGURATION){  /* 9 */
 89e:	89 30       	cpi	r24, 0x09	; 9
 8a0:	21 f4       	brne	.+8      	; 0x8aa <usbPoll+0x12c>
                    usbConfiguration = rq->wValue.bytes[0];
 8a2:	8a 81       	ldd	r24, Y+2	; 0x02
 8a4:	80 93 91 00 	sts	0x0091, r24
 8a8:	10 c0       	rjmp	.+32     	; 0x8ca <usbPoll+0x14c>
                    usbResetStall();
                }else if(rq->bRequest == USBRQ_GET_INTERFACE){      /* 10 */
 8aa:	8a 30       	cpi	r24, 0x0A	; 10
 8ac:	49 f4       	brne	.+18     	; 0x8c0 <usbPoll+0x142>
                    SET_REPLY_LEN(1);
 8ae:	8c e7       	ldi	r24, 0x7C	; 124
 8b0:	90 e0       	ldi	r25, 0x00	; 0
 8b2:	90 93 8d 00 	sts	0x008D, r25
 8b6:	80 93 8c 00 	sts	0x008C, r24
 8ba:	90 e8       	ldi	r25, 0x80	; 128
 8bc:	21 e0       	ldi	r18, 0x01	; 1
 8be:	0e c0       	rjmp	.+28     	; 0x8dc <usbPoll+0x15e>
#if USB_CFG_HAVE_INTRIN_ENDPOINT
                }else if(rq->bRequest == USBRQ_SET_INTERFACE){      /* 11 */
 8c0:	8b 30       	cpi	r24, 0x0B	; 11
 8c2:	19 f4       	brne	.+6      	; 0x8ca <usbPoll+0x14c>
/* ------------------------------------------------------------------------- */

static inline void  usbResetDataToggling(void)
{
#if USB_CFG_HAVE_INTRIN_ENDPOINT
    USB_SET_DATATOKEN1(USB_INITIAL_DATATOKEN);  /* reset data toggling for interrupt endpoint */
 8c4:	83 ec       	ldi	r24, 0xC3	; 195
 8c6:	80 93 7e 00 	sts	0x007E, r24
 8ca:	90 e8       	ldi	r25, 0x80	; 128
 8cc:	06 c0       	rjmp	.+12     	; 0x8da <usbPoll+0x15c>
                    /* 1: CLEAR_FEATURE, 3: SET_FEATURE, 7: SET_DESCRIPTOR */
                    /* 12: SYNCH_FRAME */
                }
                #undef SET_REPLY_LEN
            }else{  /* not a standard request -- must be vendor or class request */
                replyLen = usbFunctionSetup(data);
 8ce:	ce 01       	movw	r24, r28
 8d0:	53 de       	rcall	.-858    	; 0x578 <usbFunctionSetup>
 8d2:	28 2f       	mov	r18, r24
 8d4:	90 e8       	ldi	r25, 0x80	; 128
 8d6:	02 c0       	rjmp	.+4      	; 0x8dc <usbPoll+0x15e>
 8d8:	90 ec       	ldi	r25, 0xC0	; 192
 8da:	20 e0       	ldi	r18, 0x00	; 0
                    replyLen = rq->wLength.bytes[0];    /* IN transfers only */
                }
                flags &= ~USB_FLG_USE_DEFAULT_RW;  /* we have no valid msg, use user supplied read/write functions */
            }else   /* The 'else' prevents that we limit a replyLen of 0xff to the maximum transfer len. */
#endif
            if(!rq->wLength.bytes[1] && replyLen > rq->wLength.bytes[0])  /* limit length to max */
 8dc:	8f 81       	ldd	r24, Y+7	; 0x07
 8de:	88 23       	and	r24, r24
 8e0:	39 f4       	brne	.+14     	; 0x8f0 <usbPoll+0x172>
 8e2:	8e 81       	ldd	r24, Y+6	; 0x06
 8e4:	82 17       	cp	r24, r18
 8e6:	28 f0       	brcs	.+10     	; 0x8f2 <usbPoll+0x174>
 8e8:	03 c0       	rjmp	.+6      	; 0x8f0 <usbPoll+0x172>
 8ea:	90 e8       	ldi	r25, 0x80	; 128
 8ec:	80 e0       	ldi	r24, 0x00	; 0
 8ee:	01 c0       	rjmp	.+2      	; 0x8f2 <usbPoll+0x174>
 8f0:	82 2f       	mov	r24, r18
            }
            flags = 0;    /* start with a DATA1 package, stay with user supplied write() function */
        }
#endif
    }
    usbMsgFlags = flags;
 8f2:	90 93 72 00 	sts	0x0072, r25
    usbMsgLen = replyLen;
 8f6:	80 93 64 00 	sts	0x0064, r24
        usbProcessRx(usbRxBuf + USB_BUFSIZE + 1 - usbInputBufOffset, len - 3);
#if USB_CFG_HAVE_FLOWCONTROL
        if(usbRxLen > 0)    /* only mark as available if not inactivated */
            usbRxLen = 0;
#else
        usbRxLen = 0;       /* mark rx buffer as available */
 8fa:	10 92 8e 00 	sts	0x008E, r1
#endif
    }
    if(usbTxLen & 0x10){ /* transmit system idle */
 8fe:	80 91 65 00 	lds	r24, 0x0065
 902:	84 ff       	sbrs	r24, 4
 904:	49 c0       	rjmp	.+146    	; 0x998 <usbPoll+0x21a>
        if(usbMsgLen != 0xff){  /* transmit data pending? */
 906:	80 91 64 00 	lds	r24, 0x0064
 90a:	8f 3f       	cpi	r24, 0xFF	; 255
 90c:	09 f4       	brne	.+2      	; 0x910 <usbPoll+0x192>
 90e:	44 c0       	rjmp	.+136    	; 0x998 <usbPoll+0x21a>
 910:	18 2f       	mov	r17, r24
 912:	89 30       	cpi	r24, 0x09	; 9
 914:	08 f0       	brcs	.+2      	; 0x918 <usbPoll+0x19a>
 916:	18 e0       	ldi	r17, 0x08	; 8
uchar   wantLen, len, txLen, token;

    wantLen = usbMsgLen;
    if(wantLen > 8)
        wantLen = 8;
    usbMsgLen -= wantLen;
 918:	81 1b       	sub	r24, r17
 91a:	80 93 64 00 	sts	0x0064, r24
    token = USBPID_DATA1;
    if(usbMsgFlags & USB_FLG_TX_PACKET)
 91e:	80 91 72 00 	lds	r24, 0x0072
 922:	80 fd       	sbrc	r24, 0
 924:	02 c0       	rjmp	.+4      	; 0x92a <usbPoll+0x1ac>
 926:	0b e4       	ldi	r16, 0x4B	; 75
 928:	01 c0       	rjmp	.+2      	; 0x92c <usbPoll+0x1ae>
 92a:	03 ec       	ldi	r16, 0xC3	; 195
        token = USBPID_DATA0;
    usbMsgFlags++;
 92c:	8f 5f       	subi	r24, 0xFF	; 255
 92e:	80 93 72 00 	sts	0x0072, r24
static uchar usbRead(uchar *data, uchar len)
{
#if USB_CFG_IMPLEMENT_FN_READ
    if(usbMsgFlags & USB_FLG_USE_DEFAULT_RW){
#endif
        uchar i = len, *r = usbMsgPtr;
 932:	20 91 8c 00 	lds	r18, 0x008C
 936:	30 91 8d 00 	lds	r19, 0x008D
        if(usbMsgFlags & USB_FLG_MSGPTR_IS_ROM){    /* ROM data */
 93a:	86 fd       	sbrc	r24, 6
 93c:	05 c0       	rjmp	.+10     	; 0x948 <usbPoll+0x1ca>
 93e:	d9 01       	movw	r26, r18
 940:	91 2f       	mov	r25, r17
 942:	e4 e7       	ldi	r30, 0x74	; 116
 944:	f0 e0       	ldi	r31, 0x00	; 0
 946:	11 c0       	rjmp	.+34     	; 0x96a <usbPoll+0x1ec>
 948:	a4 e7       	ldi	r26, 0x74	; 116
 94a:	b0 e0       	ldi	r27, 0x00	; 0
 94c:	80 e0       	ldi	r24, 0x00	; 0
 94e:	90 e0       	ldi	r25, 0x00	; 0
 950:	06 c0       	rjmp	.+12     	; 0x95e <usbPoll+0x1e0>
            while(i--){
                uchar c = PRG_RDB(r);    /* assign to char size variable to enforce byte ops */
 952:	f9 01       	movw	r30, r18
 954:	e8 0f       	add	r30, r24
 956:	f9 1f       	adc	r31, r25
 958:	e4 91       	lpm	r30, Z+
                *data++ = c;
 95a:	ed 93       	st	X+, r30
 95c:	01 96       	adiw	r24, 0x01	; 1
#if USB_CFG_IMPLEMENT_FN_READ
    if(usbMsgFlags & USB_FLG_USE_DEFAULT_RW){
#endif
        uchar i = len, *r = usbMsgPtr;
        if(usbMsgFlags & USB_FLG_MSGPTR_IS_ROM){    /* ROM data */
            while(i--){
 95e:	18 17       	cp	r17, r24
 960:	c1 f7       	brne	.-16     	; 0x952 <usbPoll+0x1d4>
 962:	05 c0       	rjmp	.+10     	; 0x96e <usbPoll+0x1f0>
                *data++ = c;
                r++;
            }
        }else{                  /* RAM data */
            while(i--)
                *data++ = *r++;
 964:	8d 91       	ld	r24, X+
 966:	81 93       	st	Z+, r24
 968:	91 50       	subi	r25, 0x01	; 1
                uchar c = PRG_RDB(r);    /* assign to char size variable to enforce byte ops */
                *data++ = c;
                r++;
            }
        }else{                  /* RAM data */
            while(i--)
 96a:	99 23       	and	r25, r25
 96c:	d9 f7       	brne	.-10     	; 0x964 <usbPoll+0x1e6>
 96e:	f9 01       	movw	r30, r18
 970:	e1 0f       	add	r30, r17
 972:	f1 1d       	adc	r31, r1
                *data++ = *r++;
        }
        usbMsgPtr = r;
 974:	f0 93 8d 00 	sts	0x008D, r31
 978:	e0 93 8c 00 	sts	0x008C, r30
    if(usbMsgFlags & USB_FLG_TX_PACKET)
        token = USBPID_DATA0;
    usbMsgFlags++;
    len = usbRead(usbTxBuf + 1, wantLen);
    if(len <= 8){           /* valid data packet */
        usbCrc16Append(&usbTxBuf[1], len);
 97c:	84 e7       	ldi	r24, 0x74	; 116
 97e:	90 e0       	ldi	r25, 0x00	; 0
 980:	61 2f       	mov	r22, r17
 982:	c9 db       	rcall	.-2158   	; 0x116 <usbCrc16Append>
        txLen = len + 4;    /* length including sync byte */
        if(len < 8)         /* a partial package identifies end of message */
 984:	18 30       	cpi	r17, 0x08	; 8
 986:	19 f0       	breq	.+6      	; 0x98e <usbPoll+0x210>
            usbMsgLen = 0xff;
 988:	8f ef       	ldi	r24, 0xFF	; 255
 98a:	80 93 64 00 	sts	0x0064, r24
    }else{
        txLen = USBPID_STALL;   /* stall the endpoint */
        usbMsgLen = 0xff;
    }
    usbTxBuf[0] = token;
 98e:	00 93 73 00 	sts	0x0073, r16
        token = USBPID_DATA0;
    usbMsgFlags++;
    len = usbRead(usbTxBuf + 1, wantLen);
    if(len <= 8){           /* valid data packet */
        usbCrc16Append(&usbTxBuf[1], len);
        txLen = len + 4;    /* length including sync byte */
 992:	1c 5f       	subi	r17, 0xFC	; 252
    }else{
        txLen = USBPID_STALL;   /* stall the endpoint */
        usbMsgLen = 0xff;
    }
    usbTxBuf[0] = token;
    usbTxLen = txLen;
 994:	10 93 65 00 	sts	0x0065, r17
 998:	9a e0       	ldi	r25, 0x0A	; 10
/* We want to do
 *     return (USBIN & USBMASK);
 * here, but the compiler does int-expansion acrobatics.
 * We can avoid this by assigning to a char-sized variable.
 */
    rval = USBIN & USBMASK;
 99a:	86 b3       	in	r24, 0x16	; 22
        if(usbMsgLen != 0xff){  /* transmit data pending? */
            usbBuildTxBlock();
        }
    }
    for(i = 10; i > 0; i--){
        if(isNotSE0())
 99c:	88 71       	andi	r24, 0x18	; 24
 99e:	31 f4       	brne	.+12     	; 0x9ac <usbPoll+0x22e>
    if(usbTxLen & 0x10){ /* transmit system idle */
        if(usbMsgLen != 0xff){  /* transmit data pending? */
            usbBuildTxBlock();
        }
    }
    for(i = 10; i > 0; i--){
 9a0:	91 50       	subi	r25, 0x01	; 1
 9a2:	d9 f7       	brne	.-10     	; 0x99a <usbPoll+0x21c>
        if(isNotSE0())
            break;
    }
    if(i == 0){ /* RESET condition, called multiple times during reset */
        usbNewDeviceAddr = 0;
 9a4:	10 92 8f 00 	sts	0x008F, r1
        usbDeviceAddr = 0;
 9a8:	10 92 89 00 	sts	0x0089, r1

static inline void usbHandleResetHook(uchar notResetState)
{
#ifdef USB_RESET_HOOK
static uchar    wasReset;
uchar           isReset = !notResetState;
 9ac:	10 e0       	ldi	r17, 0x00	; 0
 9ae:	99 23       	and	r25, r25
 9b0:	09 f4       	brne	.+2      	; 0x9b4 <usbPoll+0x236>
 9b2:	11 e0       	ldi	r17, 0x01	; 1

    if(wasReset != isReset){
 9b4:	80 91 71 00 	lds	r24, 0x0071
 9b8:	81 17       	cp	r24, r17
 9ba:	29 f0       	breq	.+10     	; 0x9c6 <usbPoll+0x248>
        USB_RESET_HOOK(isReset);
 9bc:	11 23       	and	r17, r17
 9be:	09 f4       	brne	.+2      	; 0x9c2 <usbPoll+0x244>
 9c0:	65 de       	rcall	.-822    	; 0x68c <usbEventResetReady>
        wasReset = isReset;
 9c2:	10 93 71 00 	sts	0x0071, r17
        usbDeviceAddr = 0;
        usbResetStall();
        DBG1(0xff, 0, 0);
    }
    usbHandleResetHook(i);
}
 9c6:	df 91       	pop	r29
 9c8:	cf 91       	pop	r28
 9ca:	1f 91       	pop	r17
 9cc:	0f 91       	pop	r16
 9ce:	08 95       	ret

000009d0 <do_rand>:
 9d0:	a0 e0       	ldi	r26, 0x00	; 0
 9d2:	b0 e0       	ldi	r27, 0x00	; 0
 9d4:	ed ee       	ldi	r30, 0xED	; 237
 9d6:	f4 e0       	ldi	r31, 0x04	; 4
 9d8:	a6 c0       	rjmp	.+332    	; 0xb26 <__prologue_saves__+0x10>
 9da:	ec 01       	movw	r28, r24
 9dc:	a8 80       	ld	r10, Y
 9de:	b9 80       	ldd	r11, Y+1	; 0x01
 9e0:	ca 80       	ldd	r12, Y+2	; 0x02
 9e2:	db 80       	ldd	r13, Y+3	; 0x03
 9e4:	a1 14       	cp	r10, r1
 9e6:	b1 04       	cpc	r11, r1
 9e8:	c1 04       	cpc	r12, r1
 9ea:	d1 04       	cpc	r13, r1
 9ec:	41 f4       	brne	.+16     	; 0x9fe <do_rand+0x2e>
 9ee:	84 e2       	ldi	r24, 0x24	; 36
 9f0:	a8 2e       	mov	r10, r24
 9f2:	89 ed       	ldi	r24, 0xD9	; 217
 9f4:	b8 2e       	mov	r11, r24
 9f6:	8b e5       	ldi	r24, 0x5B	; 91
 9f8:	c8 2e       	mov	r12, r24
 9fa:	87 e0       	ldi	r24, 0x07	; 7
 9fc:	d8 2e       	mov	r13, r24
 9fe:	c6 01       	movw	r24, r12
 a00:	b5 01       	movw	r22, r10
 a02:	2d e1       	ldi	r18, 0x1D	; 29
 a04:	33 ef       	ldi	r19, 0xF3	; 243
 a06:	41 e0       	ldi	r20, 0x01	; 1
 a08:	50 e0       	ldi	r21, 0x00	; 0
 a0a:	6a d0       	rcall	.+212    	; 0xae0 <__divmodsi4>
 a0c:	27 ea       	ldi	r18, 0xA7	; 167
 a0e:	31 e4       	ldi	r19, 0x41	; 65
 a10:	40 e0       	ldi	r20, 0x00	; 0
 a12:	50 e0       	ldi	r21, 0x00	; 0
 a14:	4c d0       	rcall	.+152    	; 0xaae <__mulsi3>
 a16:	7b 01       	movw	r14, r22
 a18:	8c 01       	movw	r16, r24
 a1a:	c6 01       	movw	r24, r12
 a1c:	b5 01       	movw	r22, r10
 a1e:	2d e1       	ldi	r18, 0x1D	; 29
 a20:	33 ef       	ldi	r19, 0xF3	; 243
 a22:	41 e0       	ldi	r20, 0x01	; 1
 a24:	50 e0       	ldi	r21, 0x00	; 0
 a26:	5c d0       	rcall	.+184    	; 0xae0 <__divmodsi4>
 a28:	ca 01       	movw	r24, r20
 a2a:	b9 01       	movw	r22, r18
 a2c:	2c ee       	ldi	r18, 0xEC	; 236
 a2e:	34 ef       	ldi	r19, 0xF4	; 244
 a30:	4f ef       	ldi	r20, 0xFF	; 255
 a32:	5f ef       	ldi	r21, 0xFF	; 255
 a34:	3c d0       	rcall	.+120    	; 0xaae <__mulsi3>
 a36:	6e 0d       	add	r22, r14
 a38:	7f 1d       	adc	r23, r15
 a3a:	80 1f       	adc	r24, r16
 a3c:	91 1f       	adc	r25, r17
 a3e:	97 ff       	sbrs	r25, 7
 a40:	04 c0       	rjmp	.+8      	; 0xa4a <do_rand+0x7a>
 a42:	61 50       	subi	r22, 0x01	; 1
 a44:	70 40       	sbci	r23, 0x00	; 0
 a46:	80 40       	sbci	r24, 0x00	; 0
 a48:	90 48       	sbci	r25, 0x80	; 128
 a4a:	68 83       	st	Y, r22
 a4c:	79 83       	std	Y+1, r23	; 0x01
 a4e:	8a 83       	std	Y+2, r24	; 0x02
 a50:	9b 83       	std	Y+3, r25	; 0x03
 a52:	9b 01       	movw	r18, r22
 a54:	3f 77       	andi	r19, 0x7F	; 127
 a56:	c9 01       	movw	r24, r18
 a58:	cd b7       	in	r28, 0x3d	; 61
 a5a:	de b7       	in	r29, 0x3e	; 62
 a5c:	ea e0       	ldi	r30, 0x0A	; 10
 a5e:	7f c0       	rjmp	.+254    	; 0xb5e <__epilogue_restores__+0x10>

00000a60 <rand_r>:
 a60:	b7 df       	rcall	.-146    	; 0x9d0 <do_rand>
 a62:	08 95       	ret

00000a64 <rand>:
 a64:	80 e6       	ldi	r24, 0x60	; 96
 a66:	90 e0       	ldi	r25, 0x00	; 0
 a68:	b3 df       	rcall	.-154    	; 0x9d0 <do_rand>
 a6a:	08 95       	ret

00000a6c <srand>:
 a6c:	a0 e0       	ldi	r26, 0x00	; 0
 a6e:	b0 e0       	ldi	r27, 0x00	; 0
 a70:	80 93 60 00 	sts	0x0060, r24
 a74:	90 93 61 00 	sts	0x0061, r25
 a78:	a0 93 62 00 	sts	0x0062, r26
 a7c:	b0 93 63 00 	sts	0x0063, r27
 a80:	08 95       	ret

00000a82 <__eerd_byte_tn85>:
 a82:	e1 99       	sbic	0x1c, 1	; 28
 a84:	fe cf       	rjmp	.-4      	; 0xa82 <__eerd_byte_tn85>
 a86:	9f bb       	out	0x1f, r25	; 31
 a88:	8e bb       	out	0x1e, r24	; 30
 a8a:	e0 9a       	sbi	0x1c, 0	; 28
 a8c:	99 27       	eor	r25, r25
 a8e:	8d b3       	in	r24, 0x1d	; 29
 a90:	08 95       	ret

00000a92 <__eewr_byte_tn85>:
 a92:	26 2f       	mov	r18, r22

00000a94 <__eewr_r18_tn85>:
 a94:	e1 99       	sbic	0x1c, 1	; 28
 a96:	fe cf       	rjmp	.-4      	; 0xa94 <__eewr_r18_tn85>
 a98:	1c ba       	out	0x1c, r1	; 28
 a9a:	9f bb       	out	0x1f, r25	; 31
 a9c:	8e bb       	out	0x1e, r24	; 30
 a9e:	2d bb       	out	0x1d, r18	; 29
 aa0:	0f b6       	in	r0, 0x3f	; 63
 aa2:	f8 94       	cli
 aa4:	e2 9a       	sbi	0x1c, 2	; 28
 aa6:	e1 9a       	sbi	0x1c, 1	; 28
 aa8:	0f be       	out	0x3f, r0	; 63
 aaa:	01 96       	adiw	r24, 0x01	; 1
 aac:	08 95       	ret

00000aae <__mulsi3>:
 aae:	ff 27       	eor	r31, r31
 ab0:	ee 27       	eor	r30, r30
 ab2:	bb 27       	eor	r27, r27
 ab4:	aa 27       	eor	r26, r26

00000ab6 <__mulsi3_loop>:
 ab6:	60 ff       	sbrs	r22, 0
 ab8:	04 c0       	rjmp	.+8      	; 0xac2 <__mulsi3_skip1>
 aba:	a2 0f       	add	r26, r18
 abc:	b3 1f       	adc	r27, r19
 abe:	e4 1f       	adc	r30, r20
 ac0:	f5 1f       	adc	r31, r21

00000ac2 <__mulsi3_skip1>:
 ac2:	22 0f       	add	r18, r18
 ac4:	33 1f       	adc	r19, r19
 ac6:	44 1f       	adc	r20, r20
 ac8:	55 1f       	adc	r21, r21
 aca:	96 95       	lsr	r25
 acc:	87 95       	ror	r24
 ace:	77 95       	ror	r23
 ad0:	67 95       	ror	r22
 ad2:	89 f7       	brne	.-30     	; 0xab6 <__mulsi3_loop>
 ad4:	00 97       	sbiw	r24, 0x00	; 0
 ad6:	76 07       	cpc	r23, r22
 ad8:	71 f7       	brne	.-36     	; 0xab6 <__mulsi3_loop>

00000ada <__mulsi3_exit>:
 ada:	cf 01       	movw	r24, r30
 adc:	bd 01       	movw	r22, r26
 ade:	08 95       	ret

00000ae0 <__divmodsi4>:
 ae0:	97 fb       	bst	r25, 7
 ae2:	09 2e       	mov	r0, r25
 ae4:	05 26       	eor	r0, r21
 ae6:	0e d0       	rcall	.+28     	; 0xb04 <__divmodsi4_neg1>
 ae8:	57 fd       	sbrc	r21, 7
 aea:	04 d0       	rcall	.+8      	; 0xaf4 <__divmodsi4_neg2>
 aec:	4b d0       	rcall	.+150    	; 0xb84 <__udivmodsi4>
 aee:	0a d0       	rcall	.+20     	; 0xb04 <__divmodsi4_neg1>
 af0:	00 1c       	adc	r0, r0
 af2:	38 f4       	brcc	.+14     	; 0xb02 <__divmodsi4_exit>

00000af4 <__divmodsi4_neg2>:
 af4:	50 95       	com	r21
 af6:	40 95       	com	r20
 af8:	30 95       	com	r19
 afa:	21 95       	neg	r18
 afc:	3f 4f       	sbci	r19, 0xFF	; 255
 afe:	4f 4f       	sbci	r20, 0xFF	; 255
 b00:	5f 4f       	sbci	r21, 0xFF	; 255

00000b02 <__divmodsi4_exit>:
 b02:	08 95       	ret

00000b04 <__divmodsi4_neg1>:
 b04:	f6 f7       	brtc	.-4      	; 0xb02 <__divmodsi4_exit>
 b06:	90 95       	com	r25
 b08:	80 95       	com	r24
 b0a:	70 95       	com	r23
 b0c:	61 95       	neg	r22
 b0e:	7f 4f       	sbci	r23, 0xFF	; 255
 b10:	8f 4f       	sbci	r24, 0xFF	; 255
 b12:	9f 4f       	sbci	r25, 0xFF	; 255
 b14:	08 95       	ret

00000b16 <__prologue_saves__>:
 b16:	2f 92       	push	r2
 b18:	3f 92       	push	r3
 b1a:	4f 92       	push	r4
 b1c:	5f 92       	push	r5
 b1e:	6f 92       	push	r6
 b20:	7f 92       	push	r7
 b22:	8f 92       	push	r8
 b24:	9f 92       	push	r9
 b26:	af 92       	push	r10
 b28:	bf 92       	push	r11
 b2a:	cf 92       	push	r12
 b2c:	df 92       	push	r13
 b2e:	ef 92       	push	r14
 b30:	ff 92       	push	r15
 b32:	0f 93       	push	r16
 b34:	1f 93       	push	r17
 b36:	cf 93       	push	r28
 b38:	df 93       	push	r29
 b3a:	cd b7       	in	r28, 0x3d	; 61
 b3c:	de b7       	in	r29, 0x3e	; 62
 b3e:	ca 1b       	sub	r28, r26
 b40:	db 0b       	sbc	r29, r27
 b42:	0f b6       	in	r0, 0x3f	; 63
 b44:	f8 94       	cli
 b46:	de bf       	out	0x3e, r29	; 62
 b48:	0f be       	out	0x3f, r0	; 63
 b4a:	cd bf       	out	0x3d, r28	; 61
 b4c:	09 94       	ijmp

00000b4e <__epilogue_restores__>:
 b4e:	2a 88       	ldd	r2, Y+18	; 0x12
 b50:	39 88       	ldd	r3, Y+17	; 0x11
 b52:	48 88       	ldd	r4, Y+16	; 0x10
 b54:	5f 84       	ldd	r5, Y+15	; 0x0f
 b56:	6e 84       	ldd	r6, Y+14	; 0x0e
 b58:	7d 84       	ldd	r7, Y+13	; 0x0d
 b5a:	8c 84       	ldd	r8, Y+12	; 0x0c
 b5c:	9b 84       	ldd	r9, Y+11	; 0x0b
 b5e:	aa 84       	ldd	r10, Y+10	; 0x0a
 b60:	b9 84       	ldd	r11, Y+9	; 0x09
 b62:	c8 84       	ldd	r12, Y+8	; 0x08
 b64:	df 80       	ldd	r13, Y+7	; 0x07
 b66:	ee 80       	ldd	r14, Y+6	; 0x06
 b68:	fd 80       	ldd	r15, Y+5	; 0x05
 b6a:	0c 81       	ldd	r16, Y+4	; 0x04
 b6c:	1b 81       	ldd	r17, Y+3	; 0x03
 b6e:	aa 81       	ldd	r26, Y+2	; 0x02
 b70:	b9 81       	ldd	r27, Y+1	; 0x01
 b72:	ce 0f       	add	r28, r30
 b74:	d1 1d       	adc	r29, r1
 b76:	0f b6       	in	r0, 0x3f	; 63
 b78:	f8 94       	cli
 b7a:	de bf       	out	0x3e, r29	; 62
 b7c:	0f be       	out	0x3f, r0	; 63
 b7e:	cd bf       	out	0x3d, r28	; 61
 b80:	ed 01       	movw	r28, r26
 b82:	08 95       	ret

00000b84 <__udivmodsi4>:
 b84:	a1 e2       	ldi	r26, 0x21	; 33
 b86:	1a 2e       	mov	r1, r26
 b88:	aa 1b       	sub	r26, r26
 b8a:	bb 1b       	sub	r27, r27
 b8c:	fd 01       	movw	r30, r26
 b8e:	0d c0       	rjmp	.+26     	; 0xbaa <__udivmodsi4_ep>

00000b90 <__udivmodsi4_loop>:
 b90:	aa 1f       	adc	r26, r26
 b92:	bb 1f       	adc	r27, r27
 b94:	ee 1f       	adc	r30, r30
 b96:	ff 1f       	adc	r31, r31
 b98:	a2 17       	cp	r26, r18
 b9a:	b3 07       	cpc	r27, r19
 b9c:	e4 07       	cpc	r30, r20
 b9e:	f5 07       	cpc	r31, r21
 ba0:	20 f0       	brcs	.+8      	; 0xbaa <__udivmodsi4_ep>
 ba2:	a2 1b       	sub	r26, r18
 ba4:	b3 0b       	sbc	r27, r19
 ba6:	e4 0b       	sbc	r30, r20
 ba8:	f5 0b       	sbc	r31, r21

00000baa <__udivmodsi4_ep>:
 baa:	66 1f       	adc	r22, r22
 bac:	77 1f       	adc	r23, r23
 bae:	88 1f       	adc	r24, r24
 bb0:	99 1f       	adc	r25, r25
 bb2:	1a 94       	dec	r1
 bb4:	69 f7       	brne	.-38     	; 0xb90 <__udivmodsi4_loop>
 bb6:	60 95       	com	r22
 bb8:	70 95       	com	r23
 bba:	80 95       	com	r24
 bbc:	90 95       	com	r25
 bbe:	9b 01       	movw	r18, r22
 bc0:	ac 01       	movw	r20, r24
 bc2:	bd 01       	movw	r22, r26
 bc4:	cf 01       	movw	r24, r30
 bc6:	08 95       	ret

00000bc8 <_exit>:
 bc8:	f8 94       	cli

00000bca <__stop_program>:
 bca:	ff cf       	rjmp	.-2      	; 0xbca <__stop_program>
